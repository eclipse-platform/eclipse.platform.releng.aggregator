<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>
Layouts
</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<H2>
Layouts</H2>
<P >
We've seen some simple examples that show how to size or position child widgets based on the size of the parent. So far,
this kind of computation has occurred in response to a resize listener. This is often the best way to handle simple widget positioning. However, there are common patterns used by applications when placing widgets. These patterns can be structured as configurable layout algorithms that can be reused by many different applications.</P>
<P >
SWT defines <b> layouts</b> that provide general purpose positioning and sizing of child widgets in a composite. Layouts are subclasses of the abstract class
<b><a href="../reference/api/org/eclipse/swt/widgets/Layout.html">Layout</a></b>. The SWT standard layouts can be found in the
<b><a href="../reference/api/org/eclipse/swt/layout/package-summary.html"> org.eclipse.swt.layout</a></b> package.</P>

<P >
You should understand some general definitions when resizing and positioning
widgets. </P>
<ul>
  <li>The <b>location</b> of a widget is its x,y coordinate location within its
    parent widget.</li>
  <li>The <b>preferred size</b> of a widget is the minimum size needed to show
    its content. This is computed differently for each kind of widget.&nbsp; In
    the case of a composite, the preferred size is the minimum size that
    contains the composite and all of its children at their preferred size.</li>
  <li>The <b>clientArea</b> is the size of a widget's content area.</li>
  <li>The <b>trim</b> is the distance between a widget's client Area and its
    actual border.&nbsp; Trim is occupied by the widget's borders or extra space
    at the edge of a widget.&nbsp; The size and appearance of the trim is widget
    and platform dependent.</li>
</ul>
<P >
These concepts are relevant for applications regardless of whether a layout is used. You can think of a layout as a convenient way to package resize functionality for reuse. </P>
<P >
Some additional concepts are introduced by layouts. </P>
<ul>
  <li>Some layouts support&nbsp; <b>spacing </b>between widgets in the
    layout.&nbsp;&nbsp;</li>
  <li>Some layouts support a <b>margin</b> between the edge of the layout and
    the widget adjacent to the edge.</li>
</ul>
<P >
See <a href="http://www.eclipse.org/articles/Understanding%20Layouts/Understanding%20Layouts.htm">Understanding
Layouts in SWT</a>&nbsp; for further discussion and pictures demonstrating these concepts. </P>
<P >
The following code snippet shows the simple case of an application using a resize callback to size a label to the size of its parent shell.</P>
<font color='#4444CC'><pre>
   Display display = new Display ();
   Shell shell = new Shell (display);
   Label label = new Label (shell, SWT.CENTER);
   shell.addControlListener(new ControlAdapter() {
      public void controlResized(ControlEvent e) {
         label.setBounds (shell.getClientArea ());
      }
   });
</pre></font>
<P >
The next snippet uses a layout to achieve the same effect:</P>
<font color='#4444CC'><pre>
   Display display = new Display ();
   Shell shell = new Shell (display);
   Label label = new Label (shell, SWT.CENTER);
   shell.setLayout(new FillLayout());
</pre></font>
<P >
Even for this simple example, using a layout reduces the application code. For more complex layouts, the simplification is much greater.</P>
<P >
SWT provides four default layout classes that can be used for many situations.</P>


<p><a href="../hglegal.htm"><img border="0" src="../ngibmcpy.gif" width="250" height="12"></a></p>

</BODY>
</HTML>
