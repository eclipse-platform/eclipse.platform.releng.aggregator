<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN"><HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="../book.css" CHARSET="ISO-8859-1" TYPE="text/css">
<TITLE>Manipulating Java code</TITLE>

<link rel="stylesheet" type="text/css" HREF="../book.css">
</HEAD>
<BODY BGCOLOR="#ffffff">
<H2>
Manipulating Java code</H2>
<P>
Your plug-in can use the JDT API to create classes or interfaces, add methods to existing types, or alter the methods for types. </P>
<P>
The simplest way to alter Java objects is to use the Java element API. More general techniques can be used to work with the raw source code for a Java element.</P>

<H3>
Code modification using Java elements</h3>

<H4>
Generating a compilation unit
</h4>
<P>
The easiest way to programmatically generate a compilation unit is to use 
<b><a href="../reference/api/org/eclipse/jdt/core/IPackageFragment.html#createCompilationUnit(java.lang.String, java.lang.String, boolean, org.eclipse.core.runtime.IProgressMonitor)">IPackageFragment.createCompilationUnit</a></b>. 
You specify the name and contents of the compilation unit. The compilation unit is created inside the package and the new
<b><a href="../reference/api/org/eclipse/jdt/core/ICompilationUnit.html"> ICompilationUnit</a></b> is returned. </P>
<P>
A compilation unit can be created generically by creating a file resource whose extension is &quot;<b>.java&quot;</b> in the appropriate folder that corresponds to the package directory. Using the generic resource API is a back door to the Java tooling, so the Java model is not updated until the generic resource change listeners are
notified and the JDT listeners update the Java model with the new compilation unit.</P>


<H4>
Modifying a compilation unit
</h4>
<P>
Most simple modifications of Java source can be done using the Java element API.</P>
<P>
For example, you can query a type from a compilation unit. Once you have the <a href="../reference/api/org/eclipse/jdt/core/IType.html"><b>IType</b></a>, you can use protocols such as
<a href="../reference/api/org/eclipse/jdt/core/IType.html#createField(java.lang.String, org.eclipse.jdt.core.IJavaElement, boolean, org.eclipse.core.runtime.IProgressMonitor)"><b>createField</b></a>, 
<a href="../reference/api/org/eclipse/jdt/core/IType.html#createInitializer(java.lang.String, org.eclipse.jdt.core.IJavaElement, org.eclipse.core.runtime.IProgressMonitor)"><b>createInitializer</b></a>,
<a href="../reference/api/org/eclipse/jdt/core/IType.html#createMethod(java.lang.String, org.eclipse.jdt.core.IJavaElement, boolean, org.eclipse.core.runtime.IProgressMonitor)"><b>createMethod</b></a>, 
or <a href="../reference/api/org/eclipse/jdt/core/IType.html#createType(java.lang.String, org.eclipse.jdt.core.IJavaElement, boolean, org.eclipse.core.runtime.IProgressMonitor)"><b>createType</b></a> 
to add source code members to the type. The source code and information about the location of the member is supplied in these methods.</P>
<P>
The <b><a href="../reference/api/org/eclipse/jdt/core/ISourceManipulation.html"> ISourceManipulation</a></b> interface defines common source manipulations for Java elements. This includes methods for renaming, moving, copying, or deleting a type's member. </P>


<H4>
Working copies
</h4>
<P>
Code can be modified by manipulating the compilation unit (and thus the underlying 
<a HREF="../../org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IFile.html"><b>IFile</b></a> is modified) or
one can modify an in-memory copy of the compilation unit called a working copy. </P>
<P>
A working copy is obtained from a compilation unit using the 
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#getWorkingCopy()">getWorkingCopy</a></b>
method.  Whoever creates such a working copy is responsible for destroying it when not needed any longer using the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#destroy()">destroy</a></b>
method. </P>
<P>
Working copies modify an in-memory buffer. The <b>getWorkingCopy()</b> method creates a default buffer, but
clients can provide their own buffer implementation using the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#getWorkingCopy(org.eclipse.core.runtime.IProgressMonitor, org.eclipse.jdt.core.IBufferFactory, org.eclipse.jdt.core.IProblemRequestor)">getWorkingCopy(IProgressMonitor, IBufferFactory, IProblemRequestor)</a></b>
method. Clients can manipulate the text of this buffer directly. If they do so, they must synchronize the working copy with
the buffer from time to time using either the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#reconcile()">reconcile()</a></b>
method or the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#reconcile(boolean, org.eclipse.core.runtime.IProgressMonitor)">reconcile(boolean,IProgressMonitor)</a></b>
method.  </P>
<P>
Finally a working copy can be saved to disk (replacing the original compilation unit) using the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#commit(boolean, org.eclipse.core.runtime.IProgressMonitor)">commit</a></b>
method. </P>
<P>
For example the following code snippet creates a working copy on a compilation unit using a custom buffer factory. The snippet
modifies the buffer, reconciles the changes, commits the changes to disk and finally destroys the working copy. </P>
<font color='#4444CC'><pre>
    // Get original compilation unit
    ICompilationUnit originalUnit = ...;
    
    // Get buffer factory
    IBufferFactory factory = ...;
    
    // Create working copy
    IWorkingCopy workingCopy = originalUnit.getWorkingCopy(null, factory, null);
    
    // Modify buffer and reconcile
    IBuffer buffer = ((IOpenable)workingCopy).getBuffer();
    buffer.append("class X {}");
    workingCopy.reconcile();
    
    // Commit changes
    workingCopy.commit(false, null);
    
    // Destroy working copy
    workingCopy.destroy();
</pre></font>
<P>
Working copies can also be shared by several clients. A shared working copy is created using the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#getSharedWorkingCopy(org.eclipse.core.runtime.IProgressMonitor, org.eclipse.jdt.core.IBufferFactory, org.eclipse.jdt.core.IProblemRequestor)">getSharedWorkingCopy</a></b>
method and it can be later retrieved using the
<b><a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#findSharedWorkingCopy(org.eclipse.jdt.core.IBufferFactory)">findSharedWorkingCopy</a></b>
method. A shared working copy is thus keyed on the original compilation unit and on a buffer factory.</P>
<P>
The following shows how client 1 creates a shared working copy, client 2 retrieves this working copy, client 1 destroys the
working copy, and client 2 trying to retrieve the shared working copy notices it does not exist any longer: </P>
<font color='#4444CC'><pre>
    // Client 1: Get original compilation unit
    ICompilationUnit originalUnit = ...;
    
    // Client 1: Get buffer factory
    IBufferFactory factory = ...;
    
    // Client 1: Create shared working copy
    IWorkingCopy workingCopyForClient1 = originalUnit.getSharedWorkingCopy(null, factory, null);
    
    // Client 2: Retrieve shared working copy
    IWorkingCopy workingCopyForClient2 = originalUnit.findSharedWorkingCopy(factory);
     
    // This is the same working copy
    assert workingCopyForClient1 == workingCopyForClient2;
    
    // Client 1: Destroy shared working copy
    workingCopyForClient1.destroy();
    
    // Client 2: Attempt to retrieve shared working copy and find out it's null
    workingCopyForClient2 = originalUnit.findSharedWorkingCopy(factory);
    assert workingCopyForClient2 == null;
</pre></font>

<H3>Code modification using the DOM/AST API</h3>

There are two ways to create a <b><a href="../reference/api/org/eclipse/jdt/core/dom/CompilationUnit.html">CompilationUnit</a></b>. The first one is to use an existing compilation unit. The second
is to start from scratch using the factory methods on <b><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html">AST</a></b> (Abstract Syntax Tree).
<h4>
Creating an AST from an existing compilation unit
</h4>
This is achieved with the parse methods on <b><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html">AST</a></b>:
<ul>
<li><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html#parseCompilationUnit(char[])">parseCompilationUnit(char[])</a> This method should be used if you simply
want to create a <b><a href="../reference/api/org/eclipse/jdt/core/dom/CompilationUnit.html">CompilationUnit</a></b> without any binding resolution. Only syntax errors are
reported using this method.
</li>
<li><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html#parseCompilationUnit(char[], java.lang.String, org.eclipse.jdt.core.IJavaProject)">parseCompilationUnit(char[] source, String unitName, IJavaProject project)</a>. This method can be used to create a
<b><a href="../reference/api/org/eclipse/jdt/core/dom/CompilationUnit.html">CompilationUnit</a></b> from a byte array. If the IJavaProject is specified, the bindings can be resolved. In this case, the name of the compilation unit is used for
the binding resolution. 
</li>
<li><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html#parseCompilationUnit(org.eclipse.jdt.core.ICompilationUnit, boolean)">parseCompilationUnit(ICompilationUnit unit, boolean resolveBindings)</a>. This method can be used to create a
<b><a href="../reference/api/org/eclipse/jdt/core/dom/CompilationUnit.html">CompilationUnit</a></b> from an existing <b><a href="../reference/api/org/eclipse/jdt/core/ICompilationUnit.html">ICompilationUnit</a></b>.
</li>
</ul>
All these methods will properly set the positions for each node in the resulting tree. The resolution of bindings has to be requested
before the creation of the tree. Resolving the bindings is a costly operation and should be done only when necessary. As soon as the tree has been modified, all positions and
bindings are lost.

<h4>
From scratch
</h4>
<P>It is possible to create a <b><a href="../reference/api/org/eclipse/jdt/core/dom/CompilationUnit.html">CompilationUnit</a></b> from scratch using the factory methods on <b><a href="../reference/api/org/eclipse/jdt/core/dom/AST.html">AST</a></b>.
These method names start with <b>new...</b>. The following is an example that creates a <b>HelloWorld</b> class.
</P>
<P>The first snippet is the generated output:
<font color='#4444CC'><pre>
	package example;
	import java.util.*;
	public class HelloWorld {
		public static void main(String[] args) {
			System.out.println("Hello" + " world");
		}
	}
</pre></font>
</P>
<P>The following snippet is the corresponding code that generates the output.
<font color='#4444CC'><pre>
		CompilationUnit unit = this.ast.newCompilationUnit();
		PackageDeclaration packageDeclaration = this.ast.newPackageDeclaration();
		packageDeclaration.setName(this.ast.newSimpleName("example"));
		unit.setPackage(packageDeclaration);
		ImportDeclaration importDeclaration = this.ast.newImportDeclaration();
		QualifiedName name = 
			this.ast.newQualifiedName(
				this.ast.newSimpleName("java"),
				this.ast.newSimpleName("util"));
		importDeclaration.setName(name);
		importDeclaration.setOnDemand(true);
		unit.imports().add(importDeclaration);
		TypeDeclaration type = this.ast.newTypeDeclaration();
		type.setInterface(false);
		type.setModifiers(Modifier.PUBLIC);
		type.setName(this.ast.newSimpleName("HelloWorld"));
		MethodDeclaration methodDeclaration = this.ast.newMethodDeclaration();
		methodDeclaration.setConstructor(false);
		methodDeclaration.setModifiers(Modifier.PUBLIC | Modifier.STATIC);
		methodDeclaration.setName(this.ast.newSimpleName("main"));
		methodDeclaration.setReturnType(this.ast.newPrimitiveType(PrimitiveType.VOID));
		SingleVariableDeclaration variableDeclaration = this.ast.newSingleVariableDeclaration();
		variableDeclaration.setModifiers(Modifier.NONE);
		variableDeclaration.setType(this.ast.newArrayType(this.ast.newSimpleType(this.ast.newSimpleName("String"))));
		variableDeclaration.setName(this.ast.newSimpleName("args"));
		methodDeclaration.parameters().add(variableDeclaration);
		org.eclipse.jdt.core.dom.Block block = this.ast.newBlock();
		MethodInvocation methodInvocation = this.ast.newMethodInvocation();
		name = 
			this.ast.newQualifiedName(
				this.ast.newSimpleName("System"),
				this.ast.newSimpleName("out"));
		methodInvocation.setExpression(name);
		methodInvocation.setName(this.ast.newSimpleName("println")); 
		InfixExpression infixExpression = this.ast.newInfixExpression();
		infixExpression.setOperator(InfixExpression.Operator.PLUS);
		StringLiteral literal = this.ast.newStringLiteral();
		literal.setLiteralValue("Hello");
		infixExpression.setLeftOperand(literal);
		literal = this.ast.newStringLiteral();
		literal.setLiteralValue(" world");
		infixExpression.setRightOperand(literal);
		methodInvocation.arguments().add(infixExpression);
		ExpressionStatement expressionStatement = this.ast.newExpressionStatement(methodInvocation);
		block.statements().add(expressionStatement);
		methodDeclaration.setBody(block);
		type.bodyDeclarations().add(methodDeclaration);
		unit.types().add(type);
</pre></font>
</P>
<h4>Retrieving extra positions</h4>
The DOM/AST node contains only a pair of positions (the starting position and the length of the node). This is not always
sufficient. In order to retrieve intermediate positions, the <b><a href="../reference/api/org/eclipse/jdt/core/compiler/IScanner.html">IScanner</a></b> API should be used. For example,
we have an <b><a href="../reference/api/org/eclipse/jdt/core/dom/InstanceofExpression.html">InstanceofExpression</a></b> for which we want to know the 
positions of the <i>instanceof</i> operator.
We could write the following method to achieve this:
<font color='#4444CC'><pre>
	private int[] getOperatorPosition(Expression expression, char[] source) {
		if (expression instanceof InstanceofExpression) {
			IScanner scanner = ToolFactory.createScanner(false, false, false, false);
			scanner.setSource(source);
			int start = expression.getStartPosition();
			int end = start + expression.getLength();
			scanner.resetTo(start, end);
			int token;
			try {
				while ((token = scanner.getNextToken()) != ITerminalSymbols.TokenNameEOF) {
					switch(token) {
						case ITerminalSymbols.TokenNameinstanceof:
							return new int[] {scanner.getCurrentTokenStartPosition(), scanner.getCurrentTokenEndPosition()};
					}
				}
			} catch (InvalidInputException e) {
			}
		}
		return null;
	}
</pre></font>
The <b><a href="../reference/api/org/eclipse/jdt/core/compiler/IScanner.html">IScanner</a></b> is used to divide the input source into tokens.
Each token has a specific value that is defined in the <b><a href="../reference/api/org/eclipse/jdt/core/compiler/ITerminalSymbols.html">ITerminalSymbols</a></b> interface. It is 
fairly simple to iterate and retrieve the right token. We also recommend that you use the scanner if you want to find the 
position of the <i>super</i> keyword in a 
<b><a href="../reference/api/org/eclipse/jdt/core/dom/SuperMethodInvocation.html">SuperMethodInvocation</a></b>.
<H3>
Generic source code modification</h3>
<P>
Some source code modifications are not provided via the Java element API. A more general way to edit source code (such as changing the source code for existing elements) is accomplished using the compilation unit's raw source code and the Java DOM.</P>
<P>
These techniques include the following:</P>
<font color='#4444CC'><pre>
   // get the source for a compilation unit
   String contents = myCompilationUnit.getBuffer().getContents();

   // Create an editable JDOM
   myJDOM = new DOMFactory();
   myDOMCompilationUnit = myJDOM.createCompilationUnit(contents, &quot;MyClass&quot;);

   // Navigate and edit the compilation unit structure using 
   // JDOM node protocol. 
   ...
   // Once modififications have been made to all of the nodes 
   // get the source back from the compilation unit DOM node.
   String newContents = myDOMCompilationUnit.getContents();

   // Set this code back into the compilation unit element
   myCompilationUnit.getBuffer().setContents(newContents);

   // Save the buffer to the file.
   myCompilationUnit.save();
</pre></font>
<P>
This technique can result in problem markers being associated with incorrect line numbers, since the Java elements were not updated directly.</P>
<P>
The Java element model does not go any finer than methods and fields. The abstract syntax tree (AST) used by the compiler is not available as API, so the techniques used by the JDT to parse source into programmatic structures are not currently available as API.</P>


<H3>
Responding to changes in Java elements</h3>
<P>
If your plug-in needs to know about changes to Java elements after the fact, you can register a Java
<a href="../reference/api/org/eclipse/jdt/core/IElementChangedListener.html"><b> IElementChangedListener</b></a> with
<a href="../reference/api/org/eclipse/jdt/core/JavaCore.html"><b>JavaCore</b></a>.</P>
<font color='#4444CC'><pre>
   JavaCore.addElementChangedListener(new MyJavaElementChangeReporter());
</pre></font>
<P>
You can be more specific and specify the type of events you're interested in using 
<a href="../reference/api/org/eclipse/jdt/core/JavaCore.html#addElementChangedListener(org.eclipse.jdt.core.IElementChangedListener, int)"><b> addElementChangedListener(IElementChangedListener, int)</b></a>. </P>
<P>
For example, if you're only interested in listening for events before the builders run: </P>
<font color='#4444CC'><pre>
   JavaCore.addElementChangedListener(new MyJavaElementChangeReporter(), ElementChangedEvent.PRE_AUTO_BUILD);
</pre></font>
<P>
There are three kinds of events that are supported by <b>JavaCore</b>:
<ul>
<li><a href="../reference/api/org/eclipse/jdt/core/ElementChangedEvent.html#POST_CHANGE"><b>POST_CHANGE</b></a>: 
      Listeners of this event kind will get notified during the corresponding <b>POST_CHANGE</b> 
      resource change notification.</li>
<li><a href="../reference/api/org/eclipse/jdt/core/ElementChangedEvent.html#PRE_AUTO_BUILD"><b>PRE_AUTO_BUILD</b></a>: 
      Listeners of this event kind will get notified during the corresponding <b>PRE_AUTO_BUILD</b> 
      resource change notification.</li>
<li><a href="../reference/api/org/eclipse/jdt/core/ElementChangedEvent.html#POST_RECONCILE"><b>POST_RECONCILE</b></a>: 
      Listeners of this event kind will get notified at the end of a reconcile operation on a working copy
      (see <a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#reconcile()"><b>IWorkingCopy.reconcile()</b></a>).</li>
</ul> </P>
<P>
Java element change listeners are similar conceptually to resource change listeners
(described in
<a HREF="../../org.eclipse.platform.doc.isv/guide/resAdv_events.htm" CLASS="XRef">tracking resource changes</a>). The following snippet implements a Java element change reporter that prints the element deltas to the system console.</P>
<font color='#4444CC'><pre>
   public class MyJavaElementChangeReporter implements IElementChangedListener {
      public void elementChanged(ElementChangedEvent event) {
         IJavaElementDelta delta= event.getDelta();
         if (delta != null) {
            System.out.println(&quot;delta received: &quot;);
            System.out.print(delta);
         }
      }
   }
</pre></font>
<P>
The <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html"><b> IJavaElementDelta</b></a> includes the 
<a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#getElement()">element</a> that was
changed and <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#getFlags()">flags</a> describing 
the kind of change that occurred. Most of the time the delta tree is rooted at the Java Model level. Clients must then navigate
this delta using <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#getAffectedChildren()"><b>getAffectedChildren</b></a> 
to find out what projects have changed. </P>
<P>
The following example method traverses a delta and prints the elements that have been added, removed and changed:</P>
<font color='#4444CC'><pre>
    void traverseAndPrint(IJavaElementDelta delta) {
        switch (delta.getKind()) {
            case IJavaElementDelta.ADDED:
                System.out.println(delta.getElement() + " was added");
                break;
            case IJavaElementDelta.REMOVED:
                System.out.println(delta.getElement() + " was removed");
                break;
            case IJavaElementDelta.CHANGED:
                System.out.println(delta.getElement() + " was changed");
                if ((delta.getFlags() & IJavaElementDelta.F_CHILDREN) != 0) {
                    System.out.println("The change was in its children");
                }
                if ((delta.getFlags() & IJavaElementDelta.F_CONTENT) != 0) {
                    System.out.println("The change was in its content");
                }
                /* Others flags can also be checked */
                break;
        }
        IJavaElementDelta[] children = delta.getAffectedChildren();
        for (int i = 0; i < children.length; i++) {
            traverseAndPrint(children[i]);
        }
    }
</pre></font>

<P>
Several kinds of operations can trigger a Java element change notification. Here are some examples:
<ul>
<li>Creating a resource, e.g. <a href="../reference/api/org/eclipse/jdt/core/IPackageFragment.html#createCompilationUnit(java.lang.String, java.lang.String, boolean, org.eclipse.core.runtime.IProgressMonitor)"><b>IPackageFragment.createCompilationUnit</b></a> 
      (the delta indicates the <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#ADDED">addition</a> of the compilation unit)</li>
<li>Modifying a resource, e.g. <a href="../reference/api/org/eclipse/jdt/core/ICompilationUnit.html#createType(java.lang.String, org.eclipse.jdt.core.IJavaElement, boolean, org.eclipse.core.runtime.IProgressMonitor)"><b>ICompilationUnit.html.createType</b></a> 
     (the delta indicates that the compilation unit has <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#CHANGED">changed</a> and that a type was 
     <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#getAddedChildren()"> added as a child</a> of this compilation unit)</li>
<li>Modifying a project's classpath, e.g. <a href="../reference/api/org/eclipse/jdt/core/IJavaProject.html#setRawClasspath(org.eclipse.jdt.core.IClasspathEntry[], org.eclipse.core.runtime.IProgressMonitor)"><b>IJavaProject.html.setRawClasspath</b></a>
     (the delta indicates that package fragment roots have been <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_ADDED_TO_CLASSPATH">added to the classpath</a>, 
     <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_REMOVED_FROM_CLASSPATH">removed from the classpath</a>, or
     <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_CLASSPATH_REORDER">reordered on the classpath</a>)</li>
<li>Modifying a classpath variable value, e.g. <a href="../reference/api/org/eclipse/jdt/core/JavaCore.html#setClasspathVariable(java.lang.String, org.eclipse.core.runtime.IPath)"><b>JavaCore.html.setClasspathVariable</b></a></li>
<li>Changing the source attachment of a .jar file, e.g. <a href="../reference/api/org/eclipse/jdt/core/IPackageFragmentRoot.html#attachSource(org.eclipse.core.runtime.IPath, org.eclipse.core.runtime.IPath, org.eclipse.core.runtime.IProgressMonitor)"><b>JIPackageFragmentRoot.html.attachSource</b></a>
     (the delta indicates that the source was <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_SOURCEDETACHED">detached</a>
     then <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_SOURCEATTACHED">attached</a>)</li>
<li>Reconciling a working copy with its buffer, e.g. <a href="../reference/api/org/eclipse/jdt/core/IWorkingCopy.html#reconcile()"><b>IWorkingCopy.reconcile</b></a></li>
<li>Modifying an <a HREF="../../org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IFile.html"><b>IFile</b></a> that ends with ".java" and that is on the
      project's classpath, e.g. using <b>IFile.setContents</b> (the delta indicates that a compilation unit was changed, but 
      <a href="../reference/api/org/eclipse/jdt/core/IJavaElementDelta.html#F_FINE_GRAINED">no finer-grained information</a>
      is provided as this was not done through a Java Model operation)</li>
</ul></P>
<P>
As for 
<a HREF="../../org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IResourceDelta.html"><b>IResourceDelta</b></a> 
the Java element deltas can be batched using an 
<a HREF="../../org.eclipse.platform.doc.isv/reference/api/org/eclipse/core/resources/IWorkspaceRunnable.html"><b>IWorkspaceRunnable</b></a>. 
The deltas resulting from several Java Model operations that are run inside a <b>IWorkspaceRunnable</b> are merged and reported at once. </P>
<P>
For example the following will trigger 2 java element changes: </P>
<font color='#4444CC'><pre>
    // Get package
    IPackageFragment pkg == ....;
    
    // Create 2 compilation units
    ICompilationUnit unitA = pkg.createCompilationUnit("A.java", "public class A {}", false, null);
    ICompilationUnit unitB = pkg.createCompilationUnit("B.java", "public class B {}", false, null);
</pre></font>
<P>
Whereas the following will trigger 1 java element change: </P>
<font color='#4444CC'><pre>
    // Get package
    IPackageFragment pkg == ....;
    
    // Create 2 compilation units
    IWorkspace workspace = ResourcesPlugin.getWorkspace();
    workspace.run(
        new IWorkspaceRunnable() {
 	        public void run(IProgressMonitor monitor) throws CoreException {
 	            ICompilationUnit unitA = pkg.createCompilationUnit("A.java", "public class A {}", false, null);
 	            ICompilationUnit unitB = pkg.createCompilationUnit("B.java", "public class B {}", false, null);
 	        }
        },
        null);
</pre></font>

<P>&nbsp;<a href="../hglegal2002.htm"><img src="../ngibmcpy2002.gif" alt="Copyright IBM Corporation and others 2000, 2002. All Rights Reserved." border="0"></a>
</P>
</BODY>
</HTML>
