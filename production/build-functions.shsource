#!/usr/bin/env bash
#*******************************************************************************
# Copyright (c) 2016 IBM Corporation and others.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the Eclipse Public License v1.0
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/epl-v10.html
#
# Contributors:
#     David Williams - initial API and implementation
#*******************************************************************************

# General purpose utilities related to git and similar,
# to be sourced where needed

# this localBuildProperties.shsource file is to ease local builds to override some variables.
# It should not be used for production builds.
source localBuildProperties.shsource 2>/dev/null
ARCHIVE_HOST=${ARCHIVE_HOST:-archive.eclipse.org}
DOWNLOAD_HOST=${DOWNLOAD_HOST:-download.eclipse.org}

if [[ -z "${SCRIPT_PATH}" ]]
then
  echo -e "\n\t[ERROR] SCRIPT_PATH is not defined as expected in ${0##*/}"
  exit 1
else
  echo -e "\n\t[INFO] SCRIPT_PATH defined as ${SCRIPT_PATH}"
fi
source ${SCRIPT_PATH}/bashUtilities.shsource
source ${SCRIPT_PATH}/bootstrapVariables.shsource

# USAGE: fn-git-clone URL [BRANCH [TARGET_DIR] ]
#   URL: file:///gitroot/platform/eclipse.platform.releng.aggregator.git
#   BRANCH: R4_2_maintenance
#   TARGET_DIR: e.p.releng.aggregator
fn-git-clone ()
{
  URL="$1"; shift
  if [ $# -gt 0 ]; then
    BRANCH_CMD="-b $1"; shift
  fi
  if [ $# -gt 0 ]; then
    TARGET_DIR="$1"; shift
  fi
  # We specify --shared so that the
  # directory has group write permissions, as well as g+sx,
  # which is mostly done for easier "cleanup" of directories, etc.,
  # by anyone in "eclipse.platform.releng" group, not just genie.releng
  # owner id itself.
  echo git clone --recursive $BRANCH_CMD $URL $TARGET_DIR
  git clone --recursive $BRANCH_CMD $URL $TARGET_DIR
}

# USAGE: fn-git-checkout BRANCH | TAG
#   BRANCH: R4_2_maintenance
fn-git-checkout ()
{
  BRANCH="$1"; shift
  # always fetch before checkout, to be sure new
  # branches are in local repo (in case we are switching
  # to a new branch).
  echo git fetch current repo before checkout
  git fetch
  RC=$?
  if [[ $RC != 0 ]]
  then
    echo "[ERROR] RC from git fetch: $RC"
  else
    echo git checkout "$BRANCH" --force
    git checkout "$BRANCH" --force
    RC=$?
    if [[ $RC != 0 ]]
    then
      echo "[ERROR] RC from git checkout: $RC"
    fi
  fi
  return $RC
}

# USAGE: fn-git-pull
fn-git-pull ()
{
  echo git pull
  git pull
}

# USAGE: fn-git-submodule-update
fn-git-submodule-update ()
{
  echo "git submodule init"
  git submodule init
  echo "git submodule update --recursive"
  git submodule update --recursive
}

# USAGE: fn-git-update-submodules
fn-git-update-submodules ()
{
  echo git submodule update --init
  git submodule update --init
}

# USAGE: fn-git-clean
fn-git-clean ()
{
  # See bug 400657
  echo git clean -f -d -x
  git clean -f -d -x
  RC=$?
  if [[ $RC != 0 ]]
  then
    echo "[ERROR] RC from git clean: $RC"
    return $RC
  else
    # after initial clean, we'll also use git stash to clean up any temp commits
    # and modified tracked files, which will also call clean under the covers, I believe,
    # so may eventually want to do this first? (But, that may not allow the -x type cleanup).
    git stash
    RC=$?
    if [[ $RC != 0 ]]
    then
      echo "[ERROR] RC from git stash: $RC"
      return $RC
    else
      # we don't really want to save this stash in build directory
      git stash clear
      RC=$?
      if [[ $RC != 0 ]]
      then
        echo "[ERROR] RC from git stash clear: $RC"
        return $RC
      fi
    fi
  fi
  return 0
}

# USAGE: fn-git-reset
fn-git-reset ()
{
  echo git reset --hard  $@
  git reset --hard  $@
  RC=$?
  if [[ $RC != 0 ]]
  then
    echo "[ERROR] RC from git reset: $RC"
  fi
  return $RC
}

# USAGE: fn-git-clean-submodules
fn-git-clean-submodules ()
{
  # See bug 400657
  echo git submodule foreach git clean -f -d -x
  git submodule foreach git clean -f -d -x
  RC=$?
  if [[ $RC != 0 ]]
  then
    echo "[ERROR] RC from submodule foreach git clean: $RC"
    return $RC
  else
    # after initial clean, we'll also use git stash to clean up any temp commits
    # and modified tracked files, which will also call clean under the covers, I believe,
    # so may eventually want to do this first? (But, that may not allow the -x type cleanup).
    git submodule foreach git stash
    RC=$?
    if [[ $RC != 0 ]]
    then
      echo "[ERROR] RC from git submodule stash: $RC"
      return $RC
    else
      # we don't really want to save this stash in build directory
      git submodule foreach git stash clear
      RC=$?
      if [[ $RC != 0 ]]
      then
        echo "[ERROR] RC from git submodule stash clear: $RC"
        return $RC
      fi
    fi
  fi
  return 0
}

# USAGE: fn-git-reset-submodules
fn-git-reset-submodules ()
{
  echo git submodule foreach git reset --hard HEAD
  git submodule foreach git reset --hard HEAD
  RC=$?
  if [[ $RC != 0 ]]
  then
    echo "[ERROR] RC from submodule foreach git reset: $RC"
  fi
  return $RC
}

# USAGE: fn-local-repo URL
#   URL: git://git.eclipse.org/gitroot/platform/eclipse.platform.releng.aggregator.git
fn-local-repo ()
{
  checkNArgs $# 1
  if [[ $? != 0 ]]; then return 1; fi
  # we assume REPO_AND_ACCESS is exported from calling scripts
  URL="$1"; shift
  TO_REPLACE='git://git.eclipse.org/gitroot'
  if [[ -n "${REPO_AND_ACCESS}" && "${REPO_AND_ACCESS}" != "${TO_REPLACE}" ]]
  then
    echo $URL | sed "s!${TO_REPLACE}!${REPO_AND_ACCESS}!g"
  else
    echo $URL
  fi
}

# USAGE: fn-git-clone-aggregator GIT_CACHE URL BRANCH
#   GIT_CACHE: /shared/eclipse/builds/R4_2_maintenance/gitCache
#   URL: file:///gitroot/platform/eclipse.platform.releng.aggregator.git
#   BRANCH: R4_2_maintenance
fn-git-clone-aggregator ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  GIT_CACHE="$1"; shift
  URL="$1"; shift
  BRANCH="$1"; shift
  if [ ! -e "$GIT_CACHE" ]; then
    mkdir -p "$GIT_CACHE"
  fi
  pushd "$GIT_CACHE"
  fn-git-clone "$URL" "$BRANCH"
  popd
  pushd  $(fn-git-dir "$GIT_CACHE" "$URL" )
  fn-git-submodule-update
  popd
}

# USAGE: fn-git-clean-aggregator AGGREGATOR_DIR BRANCH
#   AGGREGATOR_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BRANCH: R4_2_maintenance
fn-git-clean-aggregator ()
{
  checkNArgs $# 2
  if [[ $? != 0 ]]; then return 1; fi
  AGGREGATOR_DIR="$1"; shift
  BRANCH="$1"; shift
  pushd "$AGGREGATOR_DIR"
  fn-complete-status "Repo state status before any cleaning."
  fn-git-clean
  RC=$?
  if [[ $RC == 0 ]]
  then
    fn-git-clean-submodules
    RC=$?
    if [[ $RC == 0 ]]
    then
      fn-complete-status "Repo state status after cleaning but before reset."
      fn-git-reset-submodules
      RC=$?
      if [[ $RC == 0 ]]
      then
        fn-complete-status "Repo state status after submodules reset but before checkout."
        fn-git-checkout "$BRANCH"
        RC=$?
        if [[ $RC == 0 ]]
        then
          fn-complete-status "Repo state status after checkout but final reset."
          fn-git-reset origin/$BRANCH
          RC=$?
          fn-complete-status "Repo state status after all cleanup in clean-aggregator."
        fi
      fi
    fi
  fi
  popd
  return $RC
}

# USAGE: fn-git-clean-aggregator AGGREGATOR_DIR BRANCH
#   AGGREGATOR_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BRANCH: R4_2_maintenance
fn-git-clean-aggregator2 ()
{
  checkNArgs $# 2
  if [[ $? != 0 ]]; then return 1; fi
  AGGREGATOR_DIR="$1"; shift
  BRANCH="$1"; shift
  pushd "$AGGREGATOR_DIR"
  fn-complete-status "Repo state status before any cleaning."
  fn-git-clean
  RC=$?
  if [[ $RC == 0 ]]
  then
    fn-git-clean-submodules
    RC=$?
    if [[ $RC == 0 ]]
    then
      fn-complete-status "Repo state status after clean but before checkout."
      fn-git-checkout "$BRANCH"
      RC=$?
      if [[ $RC == 0 ]]
      then
        fn-complete-status "Repo state status after checkout but before reset."
        fn-git-reset origin/$BRANCH
        RC=$?
        if [[ $RC == 0 ]]
        then
          fn-complete-status "Repo state status after reset but before forced update."
          fn-git-update-submodules
          RC=$?
          fn-complete-status "Repo state status after all cleanup and init in clean-aggregator."
        fi
      fi
    fi
  fi
  popd
  return $RC
}

# USAGE: fn-basebuilder-dir ROOT BUILD_ID STREAM
#   ROOT: /shared/eclipse/builds
#   BUILD_ID: M20121116-1100
#   STREAM: 4.2.2
fn-basebuilder-dir ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  ROOT="$1"; shift
  BUILD_ID="$1"; shift
  STREAM="$1"; shift
  buildDirectory=$( fn-build-dir "$ROOT" "$BUILD_ID" "$STREAM" )
  echo $buildDirectory/org.eclipse.releng.basebuilder
}


# USAGE: fn-maven-build-aggregator BUILD_ID REPO_DIR LOCAL_REPO DEBUG QUIET SIGNING MAVEN_BREE
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   LOCAL_REPO: /shared/eclipse/builds/R4_2_maintenance/localMavenRepo
#   VERBOSE: true
#   SIGNING: true
# TODO: depends on BUILD_TYPE being exported/global
fn-maven-build-aggregator ()
{
  checkNArgs $# 7
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  LOCAL_REPO="$1"; shift
  DEBUG=$1; shift
  QUIET=$1; shift
  SIGNING=$1; shift
  MAVEN_BREE=$1; shift

  # For now, we always specify --update-snapshots. We may eventually want
  # to fine tune that to use it only when we do not "clean workspace" before
  # a build. i.e. only specify for nightlies? See bug 480817.

  MARGS="-DbuildId=$BUILD_ID --update-snapshots"
  if $DEBUG; then
    MARGS="$MARGS -X -e"
  fi
  if $QUIET; then
    MARGS="$MARGS -q"
  fi
  if $SIGNING; then
    MARGS="$MARGS -Peclipse-sign"
  fi
  if [[ -n "${PATCH_BUILD}" ]]; then
    MARGS="$MARGS -P${PATCH_BUILD}"
  fi

  MARGS="$MARGS ${MAVEN_BREE}"

  export MAVEN_TMP_DIR=${MAVEN_TMP_DIR:-${TMP_DIR}}
  mkdir -p ${MAVEN_TMP_DIR}

  # Here we count on $BUILD_TYPE being exported. TODO: make parameter later?
  if [[ -n "$BUILD_TYPE" && "$BUILD_TYPE" == "N" ]]
  then
    FORCEQUALIFIERARG="-DforceContextQualifier=${BUILD_ID}"
    # always fail-fast for now. Otherwise too hard to debug.
    #FAIL_OPTION=${FAIL_OPTION:-"--fail-never"}
    FAIL_OPTION=${FAIL_OPTION:-"--fail-fast"}
    #CODE_WARNINGS="-Dcode.ignoredWarnings=-warn:-deprecation"
    # For now treat N- and I-builds the same for bug 483395 comment 21.
    CODE_WARNINGS=
  else
    # just for safety, make sure unset
    FORCEQUALIFIERARG=
    FAIL_OPTION=${FAIL_OPTION:-"--fail-fast"}
    # if not N-build, allow parent pom defaults. We unset for safety.
    CODE_WARNINGS=
  fi

  echo "DEBUG: Variables in $0"
  echo "DEBUG: BUILD_ID: $BUILD_ID"
  echo "DEBUG: REPO_DIR: $REPO_DIR"
  echo "DEBUG: LOCAL_REPO: $LOCAL_REPO"
  echo "DEBUG: DEBUG: $DEBUG"
  echo "DEBUG: QUIET: $QUIET"
  echo ""
  echo "DEBUG: CBI_JDT_REPO_URL: $CBI_JDT_REPO_URL"
  echo "DEBUG: CBI_JDT_VERSION: $CBI_JDT_VERSION"
  echo ""
  echo "DEBUG: SIGNING: $SIGNING"
  echo "DEBUG: MAVEN_BREE: $MAVEN_BREE"
  echo "DEBUG: MARGS: $MARGS"
  echo "DEBUG: FORCEQUALIFIERARG: $FORCEQUALIFIERARG"
  echo "DEBUG: CODE_WARNINGS: ${CODE_WARNINGS}"

  # --fail-at-end gives chance for bundles to compile, even after
  # a compile error. Might have to specify --fail-never to see them all? See
  # http://www.sonatype.com/books/mvnref-book/reference/running-sect-options.html#running-sect-failure-option
  # during debugging, sometimes helpful to change to --fail-fast
  pushd "$REPO_DIR"
  # lock-snapshots, if not obvious, should only be run occasionally, once ready to "stabilize"
  # mvn versions:lock-snapshots -Dmaven.repo.local=$LOCAL_REPO -Dincludes=org.eclipse.tycho*  >${logsDirectory}/lock-snapshots.txt
  # mvn versions:display-plugin-updates -Dmaven.repo.local=$LOCAL_REPO > ${logsDirectory}/display-plugin-updates.txt
  # 'dependency updates' not useful for Tycho, since its "dependencies" are via p2.
  # mvn versions:display-dependency-updates -Dmaven.repo.local=$LOCAL_REPO > ${logsDirectory}/display-dependency-updates.txt
  # mvn versions:display-property-updates -Dmaven.repo.local=$LOCAL_REPO > ${logsDirectory}/display-property-updates.txt
  # Note: we pass in bogus eclipse-p2-repo.url value (XXXXX), to help ensure no regressions of
  # bug 471835 (See bug 478483)
  # Note: reactorBuildTimestampProperty was added as a work around for bug 486698.
  # It should be removed once bug 486783 is fixed. I created bug 489510 as a reminder to remove the workaround.
  mvn $MARGS ${FAIL_OPTION} ${MAVEN_SETTINGS} -V  ${ALT_POM_FILE} \
    clean verify \
    -DskipTests=true \
    -Dmaven.repo.local=$LOCAL_REPO  $CBI_JDT_REPO_URL_ARG $CBI_JDT_VERSION_ARG \
    -Dtycho.debug.artifactcomparator -Djava.io.tmpdir=${MAVEN_TMP_DIR}\
    -Dcbi.jarsigner.continueOnFail=true -Djgit.dirtyWorkingTree=error \
    -DaggregatorBuild=true \
    -DbuildTimestamp="${TIMESTAMP}" -DbuildType="${BUILD_TYPE}"  -DbuildId="${BUILD_ID}" -Declipse-p2-repo.url="NOT_FOR_PRODUCTION_USE" ${FORCEQUALIFIERARG} ${CODE_WARNINGS} ${JAVA_DOC_TOOL}
  rc=$?
  popd
  return $rc
}

# USAGE: fn-submodule-checkout BUILD_ID REPO_DIR REPOSITORIES_TXT
#   BUILD_ID: M20121116-1100
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   SCRIPT: /shared/eclipse/builds/scripts/git-submodule-checkout.sh
#   REPOSITORIES_TXT: /shared/eclipse/builds/streams/repositories.txt
fn-submodule-checkout ()
{
  checkNArgs $# 4
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  SCRIPT="$1"; shift
  REPOSITORIES_TXT="$1"; shift
  pushd "$REPO_DIR"
  git submodule foreach "/bin/bash $SCRIPT $REPOSITORIES_TXT \$name"
  uninit=$( git submodule | grep "^-" | cut -f2 -d" " | sort -u )
  if [ ! -z "$uninit" ]; then
    echo Some modules are not initialized: $uninit
    return
  fi
  conflict=$( git submodule | grep "^U" | cut -f2 -d" " | sort -u )
  if [ ! -z "$conflict" ]; then
    echo Some modules have conflicts: $conflict
    return
  fi
  adds=$( git submodule | grep "^+" | cut -f2 -d" " )
  if [ -z "$adds" ]; then
    echo No updates for the submodules
    return
  fi
  popd
}

# USAGE: fn-add-submodule-updates REPO_DIR
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
fn-add-submodule-updates ()
{
  checkNArgs $# 1
  if [[ $? != 0 ]]; then return 1; fi
  REPO_DIR="$1"; shift
  pushd "$REPO_DIR"
  adds=$( git submodule | grep "^+" | cut -f2 -d" " )
  if [ -z "$adds" ]; then
    echo No updates for the submodules
    return
  fi
  echo git add $adds
  git add $adds
  popd
}

# USAGE: fn-tag-build-inputs BUILD_ID REPO_DIR REPOSITORIES_TXT
#   BUILD_ID: M20121116-1100
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   REPOSITORIES_TXT: /shared/eclipse/builds/streams/repositories.txt
# NOTE: the use of || : at the end of git submodules foreach commands. 
# See git submodules --help for more info ,or 
# http://stackoverflow.com/questions/19728933/continue-looping-over-submodules-with-the-git-submodule-foreach-command-after
fn-tag-build-inputs ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  REPOSITORIES_TXT="$1"; shift
  pushd "$REPO_DIR"

  # == Step 1 of git logging.
  # TODO: This may not work right if "streams/repositories.txt" contains tags.
  GITLOG_FILENAME=gitLog.txt
  GITLOG_FILE=${buildDirectory}/${GITLOG_FILENAME}
  echo "Creating ${GITLOG_FILENAME}"
  # we set REPORTDATE first thing, to get some idea of "time elapsed" since start of build.
  # While we still have "tagging" to do, we have by now checked out everything and cleaned up
  # the working tree. (So any commits after this time, would definitely not be "included" in build.
  REPORTDATE=$( date +%s )
  # we make in same format as "build id" for easy comparison.
  REPORTTIMESTAMP=$( date +%Y%m%d-%H%M --date='@'$REPORTDATE )
  # before tagging anything with current build id,
  # get the most recent tag that matches the build type
  # I am assuming BUILD_TYPE has been exported by some calling method,
  # so we have access to it without re-computing, and without passing
  # as an argument.
  # I am fairly sure this find tags in "local repo", so would work for Nightlies, as well as
  # working before we pushed current tag. If found to be empty (no changes) we could skip the build.

  # I've learned N-builds are "special", since we do not push those tags.
  # For I and M builds, though, we do want the "remote" (permanent) tag, to avoid
  # picking up tags of cancelled jobs.
  if [[ "${BUILD_TYPE}" == "N" ]]
  then
    monthInSeconds=$(( 3600 * 24 * 30 ))
    rightnow=$(date +%s)
    oneMonthAgo=$(( rightnow - monthInSeconds))
    commitish=$(git rev-list --tags="${BUILD_TYPE}*" --max-age=${oneMonthAgo} --max-count=1 )
    lastTag=$(git describe --tags --abbrev=0 ${commitish})
    if [[ ! ${lastTag} =~ ^([${BUILD_TYPE}]).*$ ]]
    then
      # Unset if was not an 'N' build (even with all the constraints specified, Git
      # will "find" an I-tag, if no N-tag satisfies the constraints.
      lastTag=""
    else
      echo "DEBUG: lastTag matched ^([${BUILD_TYPE}]).*$"
    fi
  else
    lastTag=$(git describe --tags --match "${BUILD_TYPE}*" --abbrev=0)
  fi

  # == Here is where we do the actual tagging
  git submodule foreach "if grep \"^\${name}:\" $REPOSITORIES_TXT >/dev/null; then git tag $BUILD_ID; $GIT_PUSH --verbose origin $BUILD_ID; else echo Skipping \$name; fi || :"
  git tag $BUILD_ID

  # == Step 2 of Git logging.
  if [[ -n "${lastTag}" ]]
  then
    # TODO: other log options to consider? --pretty=oneline?
    echo -e "\n\tGit log from ${lastTag} (previous) to ${BUILD_ID} (current)\n" > ${GITLOG_FILE}
    # We include the "time of report" since this report might be included in a "build has started"
    # mail message, so it would be good to know if we are much delayed in getting that message out.
    echo -e "\tThe tagging, and this report, were done at about $REPORTTIMESTAMP\n\n" >> ${GITLOG_FILE}
    # This first one is for aggregator itself.
    git log ${lastTag}..${BUILD_ID} >> ${GITLOG_FILE}
    # And now all submodules. Note we use --quiet specifically not to have the
    # "Entering <submodule>" messages printed.
    git submodule --quiet foreach git log ${lastTag}..${BUILD_ID} >> ${GITLOG_FILE}
  else
    echo -e "\n\tGit log not generated because a reasonable previous tag could not be found." > ${GITLOG_FILE}
  fi
  # == end of Git logging

  # have final push of for aggregator at end, since in future we may not build if we find "no changes"
  $GIT_PUSH --verbose origin $BUILD_ID
  popd
}

# USAGE: fn-pom-version-updater REPO_DIR LOCAL_REPO DEBUG QUIET
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   LOCAL_REPO: /shared/eclipse/builds/R4_2_maintenance/localMavenRepo
# TODO: depends on TMP_DIR being exported/global
fn-pom-version-updater ()
{

  checkNArgs $# 4
  if [[ $? != 0 ]]; then return 1; fi
  REPO_DIR="$1"; shift
  LOCAL_REPO="$1"; shift
  DEBUG=$1; shift
  QUIET=$1; shift

  MARGS=" --update-snapshots"
  if $DEBUG; then
    MARGS="$MARGS -X -e"
  fi
  if $QUIET; then
    MARGS="$MARGS -q"
  fi
  if [[ -n "${PATCH_BUILD}" ]]; then
    MARGS="$MARGS -P${PATCH_BUILD}"
  fi
  echo "DEBUG: Variables in $0"
  echo "DEBUG: PATCH_BUILD: $PATCH_BUILD"
  echo "DEBUG: REPO_DIR: $REPO_DIR"
  echo "DEBUG: LOCAL_REPO: $LOCAL_REPO"
  echo "DEBUG: DEBUG: $DEBUG"
  echo "DEBUG: QUIET: $QUIET"
  echo "DEBUG: MARGS: $MARGS"

  export MAVEN_TMP_DIR=${MAVEN_TMP_DIR:-${TMP_DIR}}
  mkdir -p ${MAVEN_TMP_DIR}

  # fail fast if not set up correctly
  rc=$(fn-check-dir-exists TMP_DIR)
  checkForErrorExit "$rc" "$rc"

  rc=$(fn-check-dir-exists MAVEN_TMP_DIR)
  checkForErrorExit "$rc" "$rc"

  report=${TMP_DIR}/pom_${BUILD_ID}.txt
  pushd "$REPO_DIR"
  mvn ${MAVEN_SETTINGS} $MARGS  ${ALT_POM_FILE} \
    org.eclipse.tycho:tycho-versions-plugin:0.26.0:update-pom \
    -Dmaven.repo.local=$LOCAL_REPO -Djava.io.tmpdir=${MAVEN_TMP_DIR}\
    -DaggregatorBuild=true \
    -DbuildTimestamp="${TIMESTAMP}" -DbuildType="${BUILD_TYPE}" -DbuildId="${BUILD_ID}" -Declipse-p2-repo.url="NOT_FOR_PRODUCTION_USE"
  RC=$?
  if [[ $RC != 0 ]]
  then
    echo "ERROR: tycho-versions-plugin:update-pom returned non-zero return code: $RC" >&2
  else
    changes=$( git status --short -uno | cut -c4- )
    if [ -z "$changes" ]; then
      echo "INFO: No changes in pom versions" >&2
      RC=0
    else
      echo "INFO: Changes in pom versions: $changes" >&2
      RC=0
    fi
  fi
  popd
  return $RC
}


# USAGE: fn-gather-repo BUILD_ID REPO_DIR BUILD_DIR
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
fn-gather-repo ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  if [[ -n "${PATCH_BUILD}" ]]
  then
    PATCH_BUILD_GENERIC=java9patch
    ORIG_PATH=eclipse.platform.releng.tychoeclipsebuilder/${PATCH_BUILD}/eclipse.releng.repository.${PATCH_BUILD_GENERIC}/target/site
    TARGET_PATH=eclipse.platform.releng.tychoeclipsebuilder/${PATCH_BUILD}/eclipse.releng.repository.${PATCH_BUILD_GENERIC}/target/repository
    ORIG_DIR_REPOSITORY=$REPO_DIR/${ORIG_PATH}
    REPO_DIR_REPOSITORY=$REPO_DIR/${TARGET_PATH}
    # old site update-site repos are created in 'site', so we move to 'repository'
    # newer eclipse-repository are in 'repository' already.
    if [[ -e "${ORIG_PATH}" ]]
    then
      mv ${ORIG_DIR_REPOSITORY} ${REPO_DIR_REPOSITORY}
    fi

  else
    TARGET_PATH=eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/target/repository
    REPO_DIR_REPOSITORY=$REPO_DIR/$TAGET_PATH
  fi
  if [[ -d "$REPO_DIR_REPOSITORY" ]]
  then
    pushd "$REPO_DIR"
    cp -r ${TARGET_PATH} $BUILD_DIR
    popd
  else
    echo "   ERROR: $REPO_DIR_REPOSITORY did not exist in fn-gather-repo"
  fi
}



# USAGE: fn-gather-sdk BUILD_ID REPO_DIR BUILD_DIR
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
fn-gather-sdk ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  TARGET_PRODUCTS="$REPO_DIR"/eclipse.platform.releng.tychoeclipsebuilder/sdk/target/products
  buildType=$(echo $BUILD_ID|cut -b1)
  if [[ -d "$TARGET_PRODUCTS" ]]
  then
    pushd "$TARGET_PRODUCTS"
    cp org.eclipse.sdk.ide-linux.gtk.ppc.tar.gz "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-linux-gtk-ppc.tar.gz
    cp org.eclipse.sdk.ide-linux.gtk.ppc64.tar.gz "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-linux-gtk-ppc64.tar.gz
    cp org.eclipse.sdk.ide-linux.gtk.x86_64.tar.gz "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-linux-gtk-x86_64.tar.gz
    cp org.eclipse.sdk.ide-linux.gtk.x86.tar.gz "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-linux-gtk.tar.gz
    cp org.eclipse.sdk.ide-macosx.cocoa.x86_64.tar.gz "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-macosx-cocoa-x86_64.tar.gz
    cp org.eclipse.sdk.ide-win32.win32.x86_64.zip "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-win32-x86_64.zip
    cp org.eclipse.sdk.ide-win32.win32.x86.zip "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-win32.zip
    if [ "$buildType" == "M" ]
    then
      cp org.eclipse.sdk.ide-aix.gtk.ppc64.zip "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-aix-gtk-ppc64.zip
      cp org.eclipse.sdk.ide-aix.gtk.ppc.zip "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-aix-gtk-ppc.zip
      cp org.eclipse.sdk.ide-hpux.gtk.ia64.zip "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-hpux-gtk-ia64.zip
      cp org.eclipse.sdk.ide-linux.gtk.ppc64le.tar.gz "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-linux-gtk-ppc64le.tar.gz
      cp org.eclipse.sdk.ide-linux.gtk.s390.tar.gz "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-linux-gtk-s390.tar.gz
      cp org.eclipse.sdk.ide-linux.gtk.s390x.tar.gz "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-linux-gtk-s390x.tar.gz
      cp org.eclipse.sdk.ide-solaris.gtk.sparcv9.zip "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-solaris-gtk-sparcv9.zip
      cp org.eclipse.sdk.ide-solaris.gtk.x86_64.zip "$BUILD_DIR"/eclipse-SDK-${BUILD_ID}-solaris-gtk-x86_64.zip
    fi
    popd
  else
    echo "   ERROR: $TARGET_PRODUCTS did not exist in fn-gather-sdks"
  fi
}

# USAGE: fn-gather-platform BUILD_ID REPO_DIR BUILD_DIR
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
fn-gather-platform ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  TARGET_PRODUCTS="$REPO_DIR"/eclipse.platform.releng.tychoeclipsebuilder/platform/target/products
  buildType=$(echo $BUILD_ID|cut -b1)
  if [[ -d "$TARGET_PRODUCTS" ]]
  then
    pushd "$TARGET_PRODUCTS"
    cp org.eclipse.platform.ide-linux.gtk.ppc.tar.gz "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-linux-gtk-ppc.tar.gz
    cp org.eclipse.platform.ide-linux.gtk.ppc64.tar.gz "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-linux-gtk-ppc64.tar.gz
    cp org.eclipse.platform.ide-linux.gtk.x86_64.tar.gz "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-linux-gtk-x86_64.tar.gz
    cp org.eclipse.platform.ide-linux.gtk.x86.tar.gz "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-linux-gtk.tar.gz
    cp org.eclipse.platform.ide-macosx.cocoa.x86_64.tar.gz "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-macosx-cocoa-x86_64.tar.gz
    cp org.eclipse.platform.ide-win32.win32.x86_64.zip "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-win32-x86_64.zip
    cp org.eclipse.platform.ide-win32.win32.x86.zip "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-win32.zip
    if [ "$buildType" == "M" ]
    then
      cp org.eclipse.platform.ide-aix.gtk.ppc64.zip "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-aix-gtk-ppc64.zip
      cp org.eclipse.platform.ide-aix.gtk.ppc.zip "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-aix-gtk-ppc.zip
      cp org.eclipse.platform.ide-hpux.gtk.ia64.zip "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-hpux-gtk-ia64.zip
      cp org.eclipse.platform.ide-linux.gtk.ppc64le.tar.gz "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-linux-gtk-ppc64le.tar.gz
      cp org.eclipse.platform.ide-linux.gtk.s390.tar.gz "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-linux-gtk-s390.tar.gz
      cp org.eclipse.platform.ide-linux.gtk.s390x.tar.gz "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-linux-gtk-s390x.tar.gz
      cp org.eclipse.platform.ide-solaris.gtk.sparcv9.zip "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-solaris-gtk-sparcv9.zip
      cp org.eclipse.platform.ide-solaris.gtk.x86_64.zip "$BUILD_DIR"/eclipse-platform-${BUILD_ID}-solaris-gtk-x86_64.zip
    fi
    popd
  else
    echo "   ERROR: $TARGET_PRODUCTS did not exist in fn-gather-platform"
  fi
}

# USAGE: fn-gather-swt-zips BUILD_ID REPO_DIR BUILD_DIR
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
fn-gather-swt-zips ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  # TODO: this directory sanity check does not accomplish much, since binaries/bundles always
  # exists. Results in a 'not found' msg. Doubt there is any simple solution.
  SWT_BUNDLES_DIR="$REPO_DIR"/eclipse.platform.swt.binaries/bundles
  if [[ -d "$SWT_BUNDLES_DIR" ]]
  then
    pushd "$SWT_BUNDLES_DIR"
    cp  */target/*.zip "$BUILD_DIR"
    popd
  else
    echo "   ERROR: $SWT_BUNDLES_DIR did not exist in fn-gather-swt-zips"
  fi
}

# USAGE: fn-gather-test-zips BUILD_ID REPO_DIR BUILD_DIR
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
fn-gather-test-zips ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  TEST_ZIP_DIR="$REPO_DIR"/eclipse.platform.releng.tychoeclipsebuilder/eclipse-junit-tests/target
  if [[ -d "$TEST_ZIP_DIR" ]]
  then
    pushd "$TEST_ZIP_DIR"
    cp eclipse-junit-tests-bundle.zip "$BUILD_DIR"/eclipse-Automated-Tests-${BUILD_ID}.zip
    TEST_FRAMEWORK_DIR=$TEST_ZIP_DIR/eclipse-test-framework
    if [[ -d "$TEST_FRAMEWORK_DIR" ]]
    then
      pushd "$TEST_FRAMEWORK_DIR"
      zip -r "$BUILD_DIR"/eclipse-test-framework-${BUILD_ID}.zip *
      popd
    else
      echo "   ERROR: $TEST_FRAMEWORK_DIR did not exist in fn-gather-test-zips."
    fi
    popd
  else
    echo "   ERROR: $TEST_ZIP_DIR did not exist in fn-gather-test-zips."
  fi
}


# USAGE: fn-gather-ecj-jars BUILD_ID REPO_DIR BUILD_DIR
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
fn-gather-ecj-jars ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  ECJ_JAR_DIR="$REPO_DIR"/eclipse.jdt.core/org.eclipse.jdt.core/target
  if [[ -d "$ECJ_JAR_DIR" ]]
  then
    pushd "$ECJ_JAR_DIR"
    # The blob wildcard ('*') is to match "any version number", e.g. 3.9.0, 3.9.1, etc.
    cp org.eclipse.jdt.core-*-SNAPSHOT-batch-compiler.jar "$BUILD_DIR"/ecj-${BUILD_ID}.jar
    cp org.eclipse.jdt.core-*-SNAPSHOT-batch-compiler-src.jar "$BUILD_DIR"/ecjsrc-${BUILD_ID}.jar
    popd
  else
    echo "   ERROR: $ECJ_JAR_DIR did not exist in fn-gather-ecj-jars."
    #TODO eventually, fail the build here? If they do not exist, something must be pretty wrong?
  fi
}



# USAGE: fn-slice-repos BUILD_ID REPO_DIR BUILD_DIR BASEBUILDER_LAUNCHER
#   BUILD_ID: I20121116-0700
#   ANT_SCRIPT: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
#   BASEBUILDER_LAUNCHER: /shared/eclipse/builds/R4_2_maintenance/org.eclipse.releng.basebuilder_R3_7/plugins/org.eclipse.equinox.launcher_1.2.0.v20110502.jar
fn-slice-repos ()
{
  checkNArgs $# 4
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  BASEBUILDER_LAUNCHER="$1"; shift
  ANT_SCRIPT="$REPO_DIR"/eclipse.platform.releng.tychoeclipsebuilder/repos/buildAll.xml
  REPO_DIR_DIR="$REPO_DIR"/eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/target/repository
  if [[ -d "$REPO_DIR_DIR" ]]
  then
    pushd "$REPO_DIR"
    java -Djava.io.tmpdir=$TMP_DIR -jar "$BASEBUILDER_LAUNCHER" \
      -data ${BUILD_DIR}/workspace-buildrepos \
      -application org.eclipse.ant.core.antRunner \
      -buildfile "$ANT_SCRIPT" \
      -Declipse.build.configs="$REPO_DIR"/eclipse.platform.releng.tychoeclipsebuilder \
      -DbuildId="$BUILD_ID" \
      -DbuildRepo="$REPO_DIR_DIR" \
      -DpostingDirectory=$(dirname "$BUILD_DIR") \
      -DequinoxPostingDirectory="$BUILD_ROOT/siteDir/equinox/drops" \
      -DbuildLabel="$BUILD_ID" \
      -Djava.io.tmpdir=$TMP_DIR \
      -DbuildDirectory="$BUILD_DIR"
    RC=$?
    popd
    if [[ $RC != 0 ]]
    then
      BUILD_FAILED="${buildDirectory}/buildFailed-slice-repo-error"
      echo "   ERROR: Java antrunner call with $ANT_SCRIPT returned non-zero return code, $RC, in fn-slice-repo" >>${BUILD_FAILED}
      return $RC
    fi
  else
    BUILD_FAILED="${buildDirectory}/buildFailed-slice-repo-error"
    echo "   ERROR: $REPO_DIR_DIR did not exist in fn-slice-repo. Probably due to an earlier error?" >>${BUILD_FAILED}
    return 1
  fi
}


# USAGE: fn-gather-repo-zips BUILD_ID REPO_DIR BUILD_DIR
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
fn-gather-repo-zips ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  if [[ -d "$REPO_DIR" ]]
  then
    pushd "$REPO_DIR"/eclipse.platform.repository/target/repos
    for r in org.eclipse.*; do
      pushd $r
      zip -r "$BUILD_DIR"/${r}-${BUILD_ID}.zip *
      popd
    done
    popd
  else
    echo "   ERROR: $REPO_DIR did not exist in fn-gather-repo-zips"
  fi
}

# TODO: could probably remove this function. It has been replaced
# by fn-gather-23-compile-log as long as we are on Tycho 23 or above.
# USAGE: fn-gather-compile-logs BUILD_ID REPO_DIR BUILD_DIR
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
fn-gather-compile-logs ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  if [[ -d "$REPO_DIR" ]]
  then
    mkdir -p "$BUILD_DIR"/compilelogs/plugins
    pushd "$REPO_DIR"
    for dot in $( find * -name "@dot.xml" ); do
      targetDir=$( dirname "$dot" )
      echo "Processing $dot in $targetDir"
      if [ ! -r "$targetDir"/MANIFEST.MF ]; then
        echo "**Failed to process $dot in $targetDir. Likely compile error. Will try source MANIFEST.MF in directory containing target."
        targetDir=$( dirname "${targetDir}" )
        if [ ! -r "$targetDir"/META-INF/MANIFEST.MF ]
        then
          echo "**Failed to process $dot in $targetDir."
        else
          BUNDLE_ID=$( grep Bundle-SymbolicName "$targetDir"/META-INF/MANIFEST.MF | cut -f2 -d" " |  cut -f1 -d\; | tr -d '\f\r\n\t' )
          BUNDLE_VERSION=$(  grep Bundle-Version "$targetDir"/META-INF/MANIFEST.MF | cut -f2 -d" " | tr -d '\f\r\n\t' )
          mkdir "$BUILD_DIR"/compilelogs/plugins/${BUNDLE_ID}_${BUNDLE_VERSION}
          cp "$dot" "$BUILD_DIR"/compilelogs/plugins/${BUNDLE_ID}_${BUNDLE_VERSION}
        fi
      else
        BUNDLE_ID=$( grep Bundle-SymbolicName "$targetDir"/MANIFEST.MF | cut -f2 -d" " |  cut -f1 -d\; | tr -d '\f\r\n\t' )
        BUNDLE_VERSION=$(  grep Bundle-Version "$targetDir"/MANIFEST.MF | cut -f2 -d" " | tr -d '\f\r\n\t' )
        mkdir "$BUILD_DIR"/compilelogs/plugins/${BUNDLE_ID}_${BUNDLE_VERSION}
        cp "$dot" "$BUILD_DIR"/compilelogs/plugins/${BUNDLE_ID}_${BUNDLE_VERSION}
      fi
    done
    popd
  else
    echo "[ERROR] $REPO_DIR did not exist in fn-gather-compile-logs"
  fi
}

# USAGE: fn-gather-23-compile-logs BUILD_ID REPO_DIR BUILD_DIR
# This method for use when using Tycho 0.23.0 or greater, due to
# fix for multi-jar bundles.
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
fn-gather-23-compile-logs ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  if [[ -d "$REPO_DIR" ]]
  then
    COLLECTED_LOGS_DIR="${BUILD_DIR}/compilelogs/plugins"
    mkdir -p "${COLLECTED_LOGS_DIR}"
    pushd "$REPO_DIR"
    # The directory 'compilelogs' is used when we generate the logs. See parent pom for compilerArgs.
    for log in $( find "${REPO_DIR}" -name "compilelogs" -type d ); do
      targetDir=$( dirname "$log" )
      # Remember to remove INFO echo, after confirmed working
      echo -e "\t[INFO] Processing \n\t$log\n\tin\n\t$targetDir"
      if [ ! -r "$targetDir"/MANIFEST.MF ]; then
        echo -e "\n\t** Failed to process\n\t$log in \n\t$targetDir. \n\tLikely compile error? Will backup to source MANIFEST.MF in directory containing target."
        targetDir=$( dirname "${targetDir}" )
        if [ ! -r "$targetDir"/META-INF/MANIFEST.MF ]
        then
          echo "**Failed to process $log in $targetDir."
        else
          BUNDLE_ID=$( grep Bundle-SymbolicName "$targetDir"/META-INF/MANIFEST.MF | cut -f2 -d" " |  cut -f1 -d\; | tr -d '\f\r\n\t' )
          BUNDLE_VERSION=$(  grep Bundle-Version "$targetDir"/META-INF/MANIFEST.MF | cut -f2 -d" " | tr -d '\f\r\n\t' )
          mkdir -p "${COLLECTED_LOGS_DIR}/${BUNDLE_ID}_${BUNDLE_VERSION}"
          rsync -vr "${log}/" "${COLLECTED_LOGS_DIR}/${BUNDLE_ID}_${BUNDLE_VERSION}/"
        fi
      else
        BUNDLE_ID=$( grep Bundle-SymbolicName "$targetDir"/MANIFEST.MF | cut -f2 -d" " |  cut -f1 -d\; | tr -d '\f\r\n\t' )
        BUNDLE_VERSION=$(  grep Bundle-Version "$targetDir"/MANIFEST.MF | cut -f2 -d" " | tr -d '\f\r\n\t' )
        # directory may not be "new", since we now collect @dot.xml, plus nested jar compile logs, of the form <jarName>.jar.xml
        # as well as handy for "re-running"
        mkdir -p "${COLLECTED_LOGS_DIR}/${BUNDLE_ID}_${BUNDLE_VERSION}"
        # All logs should be directly under $log, but ... will specify -r in case not.
        # Remember to remove 'v' after confirmed working
        rsync -vr "${log}/" "${COLLECTED_LOGS_DIR}/${BUNDLE_ID}_${BUNDLE_VERSION}/"
      fi
    done
    popd
  else
    echo "[ERROR] $REPO_DIR did not exist in fn-gather-23-compile-logs"
  fi
}
#   fn-gather-buildnotes
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
function fn-gather-buildnotes
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  echo "collecting buildnotes"
  if [[ -d "$REPO_DIR" ]]
  then
    pushd "$REPO_DIR"
    buildnotesDir="${BUILD_DIR}/buildnotes"
    mkdir -p ${buildnotesDir}
    find . -name "buildnotes_*.html" -exec rsync '{}' ${buildnotesDir}  \;
    popd
  else
    echo "   ERROR: $REPO_DIR did not exist in fn-gather-buildnotes"
    return 1
  fi
}
#   fn-gather-artifactcomparisons
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
# TODO: this may take a while, for something that usually won't be found.
# could skip for N-builds. Plus, could check if size of log was greater than minimum.
# see syncDropLocation for current home of that "check".
function fn-gather-artifactcomparisons
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  echo "collecting artifactcomparisons"
  if [[ -d "$REPO_DIR" ]]
  then
    pushd "$REPO_DIR"
    mkdir -p "${BUILD_DIR}/buildlogs/comparatorlogs"
    find . -regex ".*target/artifactcomparison" -type d -exec zip -r  "${BUILD_DIR}/buildlogs/comparatorlogs/artifactcomparisons.zip" '{}' \;
    popd
  else
    echo "   ERROR: $REPO_DIR did not exist in fn-gather-artifactcomparisons"
    return 1
  fi
}



# USAGE: fn-gather-main-index BUILD_ID REPO_DIR BUILD_DIR STREAM BUILD_TYPE BUILD_PRETTY_DATE
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
#   STREAM: 4.2.2
#   BUILD_TYPE: M, I, N, X, Y, P
#   BUILD_PRETTY_DATE: Thu Nov 20 17:47:35 EST 2012
fn-gather-main-index ()
{
  checkNArgs $# 6
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  STREAM="$1"; shift
  BUILD_TYPE="$1"; shift
  BUILD_PRETTY_DATE="$1"; shift
  pushd "$REPO_DIR"/eclipse.platform.releng.tychoeclipsebuilder/eclipse/templateFiles

  # Simplified by creating PHP variables in buildproperties.php
  cp "index.template_${PATCH_OR_BRANCH_LABEL}.php" "$BUILD_DIR"/index.php

  popd
}

# USAGE: fn-parse-compile-logs BUILD_ID ANT_SCRIPT BUILD_DIR BASEBUILDER_LAUNCHER
#   BUILD_ID: I20121116-0700
#   ANT_SCRIPT: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
#   BASEBUILDER_LAUNCHER: /shared/eclipse/builds/R4_2_maintenance/org.eclipse.releng.basebuilder_R3_7/plugins/org.eclipse.equinox.launcher_1.2.0.v20110502.jar
fn-parse-compile-logs ()
{
  checkNArgs $# 4
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  ANT_SCRIPT="$1"; shift
  BUILD_DIR="$1"; shift
  BASEBUILDER_LAUNCHER="$1"; shift
  EBuilderDir="${BUILD_DIR}/eclipse.platform.releng.aggregator/eclipse.platform.releng.tychoeclipsebuilder"
  pushd "$BUILD_DIR"
  java -Djava.io.tmpdir=$TMP_DIR -jar "$BASEBUILDER_LAUNCHER" \
    -data ${BUILD_DIR}/workspace-verifyCompile \
    -application org.eclipse.ant.core.antRunner \
    -buildfile "$ANT_SCRIPT" \
    -DpostingDirectory=$(dirname $BUILD_DIR) \
    -DbuildDirectory="$BUILD_DIR" \
    -DEBuilderDir="${EBuilderDir}" \
    -DbuildId="$BUILD_ID" \
    -DbuildLabel="$BUILD_ID" \
    -Djava.io.tmpdir=$TMP_DIR \
    verifyCompile
  popd
}

# USAGE: fn-summarize-comparator-logs BUILD_ID ANT_SCRIPT BUILD_DIR BASEBUILDER_LAUNCHER
#   BUILD_ID: I20121116-0700
#   ANT_SCRIPT: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
#   BASEBUILDER_LAUNCHER: /shared/eclipse/builds/R4_2_maintenance/org.eclipse.releng.basebuilder_R3_7/plugins/org.eclipse.equinox.launcher_1.2.0.v20110502.jar
#   TODO: I think this could be pure ant task
fn-summarize-comparator-logs ()
{
  checkNArgs $# 4
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  ANT_SCRIPT="$1"; shift
  BUILD_DIR="$1"; shift
  BASEBUILDER_LAUNCHER="$1"; shift
  EBuilderDir="${BUILD_DIR}/eclipse.platform.releng.aggregator/eclipse.platform.releng.tychoeclipsebuilder"
  pushd "$BUILD_DIR"
  java -Djava.io.tmpdir=$TMP_DIR -jar "$BASEBUILDER_LAUNCHER" \
    -data ${BUILD_DIR}/workspace-comparatorLogs \
    -application org.eclipse.ant.core.antRunner \
    -buildfile "$ANT_SCRIPT" \
    -DbuildDirectory="$BUILD_DIR" \
    -DEBuilderDir="${EBuilderDir}" \
    -DbuildId="$BUILD_ID" \
    -DbuildLabel="$BUILD_ID" \
    -Djava.io.tmpdir=$TMP_DIR \
    compare
  popd
}
# USAGE: fn-summarize-apitooling BUILD_ID ANT_SCRIPT BUILD_DIR BASEBUILDER_LAUNCHER
#   BUILD_ID: I20121116-0700
#   ANT_SCRIPT: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
#   BASEBUILDER_LAUNCHER: /shared/eclipse/builds/R4_2_maintenance/org.eclipse.releng.basebuilder_R3_7/plugins/org.eclipse.equinox.launcher_1.2.0.v20110502.jar
#   TODO: could avoid some of the hard coding of "previous version" and URL
fn-summarize-apitooling ()
{
  checkNArgs $# 4
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  ANT_SCRIPT="$1"; shift
  BUILD_DIR="$1"; shift
  BASEBUILDER_LAUNCHER="$1"; shift
  EBuilderDir=$BUILD_DIR/eclipse.platform.releng.aggregator/eclipse.platform.releng.tychoeclipsebuilder
  pushd "$BUILD_DIR"
  # Make sure FREEZE_PARAMS is defined, but empty space, if not using freeze reports.
  FREEZE_PARAMS=" "
  # When no "freeze" in effect for a release comment these out. Uncomment after M6, changing to appropriate versions.
#  FREEZE_PARAMS="-DfreezeBaseURL=http://${ARCHIVE_HOST}/eclipse/downloads/drops4/S-4.7M6-2017mmddhhmm/eclipse-SDK-4.7M6-win32.zip \
#    -DfreezeName=Eclipse-SDK-4.7M6 \
#    -DfreezeFilename=eclipse-SDK-4.7M6-win32.zip "
  # this API_PREV_REF_LABEL variable should be changed any time the version used
  # by previousBaseURL changes. Its purpose is just to localize changes to this one
  # place, and not have to make further, hard-coded changes to php files.
  # Similar for freeze label.
  # NOTE: the *reference* for API changes should be the "previous release", even if it is a "service release".
  API_PREV_REF_LABEL=4.6.2
  fn-write-property API_PREV_REF_LABEL
#  API_FREEZE_REF_LABEL=4.7M6
  API_FREEZE_REF_LABEL=" "
  fn-write-property API_FREEZE_REF_LABEL
  java -Djava.io.tmpdir=$TMP_DIR -jar "$BASEBUILDER_LAUNCHER" \
    -data ${BUILD_DIR}/workspace-apitoolingsLogs \
    -application org.eclipse.ant.core.antRunner \
    -buildfile "$ANT_SCRIPT" \
    -DbuildDirectory="$BUILD_DIR" \
    -DEBuilderDir=$EBuilderDir \
    -DbuildId="$BUILD_ID" \
    -DbuildLabel="$BUILD_ID" \
    -DbuildWorkingArea="${BUILD_HOME}/4${BUILD_TYPE}/gitCache/eclipse.platform.releng.aggregator" \
    -DpreviousBaseURL=http://${ARCHIVE_HOST}/eclipse/downloads/drops4/R-4.6.2-201611241400/eclipse-SDK-4.6.2-win32.zip \
    -DpreviousBaselineName=Eclipse-SDK-4.6.2 \
    -DpreviousBaselineFilename=eclipse-SDK-4.6.2-win32.zip \
    -Djava.io.tmpdir=$TMP_DIR \
    ${FREEZE_PARAMS} \
    apiToolsReports
  popd
}

# USAGE: fn-publish-eclipse BUILD_TYPE BUILD_STREAM BUILD_ID REPO_DIR BUILD_DIR BASEBUILDER_LAUNCHER
#   BUILD_TYPE: I
#   BUILD_STREAM: 4.2.2
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
#   BASEBUILDER_LAUNCHER: /shared/eclipse/builds/R4_2_maintenance/org.eclipse.releng.basebuilder_R3_7/plugins/org.eclipse.equinox.launcher_1.2.0.v20110502.jar
fn-publish-eclipse ()
{
  checkNArgs $# 6
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_TYPE="$1"; shift
  BUILD_STREAM="$1"; shift
  BUILD_ID="$1"; shift
  AGGR_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  BASEBUILDER_LAUNCHER="$1"; shift
  EBuilderDir="$BUILD_DIR"/eclipse.platform.releng.aggregator/eclipse.platform.releng.tychoeclipsebuilder
  pushd "$BUILD_DIR"
  java -Djava.io.tmpdir=$TMP_DIR -jar "$BASEBUILDER_LAUNCHER" \
    -data ${BUILD_DIR}/workspace-publish \
    -application org.eclipse.ant.core.antRunner \
    -v \
    -buildfile "$EBuilderDir"/eclipse/helper.xml \
    -DbuildId="$BUILD_ID" \
    -DbuildRepo="$AGGR_DIR"/eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/target/repository \
    -DpostingDirectory="$BUILD_ROOT/siteDir/eclipse/downloads/drops4" \
    -DequinoxPostingDirectory="$BUILD_ROOT/siteDir/equinox/drops" \
    -DpublishingContent="$EBuilderDir"/eclipse/publishingFiles \
    -DdropTemplateFileName="${EBuilderDir}/eclipse/publishingFiles/templateFiles/index.template_${PATCH_OR_BRANCH_LABEL}.php" \
    -DindexFileName="index.php" \
    -DbuildLabel="$BUILD_DIR_SEG" \
    -DEBuilderDir="$EBuilderDir" \
    -DAGGR_DIR="$AGGR_DIR" \
    -DeclipseStream=$BUILD_STREAM \
    -DbuildType="$BUILD_TYPE" \
    -Dbase.builder=$(dirname $(dirname "$BASEBUILDER_LAUNCHER" ) ) \
    -DbuildDirectory="$BUILD_DIR" \
    -Djava.io.tmpdir=$TMP_DIR \
    publish
  # hide experimental builds, for now
  if [[ $BUILD_TYPE =~ [PXY] ]]
  then
    touch buildHidden
  fi
  popd
}

# USAGE: fn-checkout-basebuilder BUILDER_DIR
#   BUILDER_DIR: /shared/eclipse/builds/R4_2_maintenance/org.eclipse.releng.basebuilder_R3_7
fn-checkout-basebuilder ()
{
  checkNArgs $# 1
  if [[ $? != 0 ]]; then return 1; fi
  BUILDER_DIR="$1"; shift
  if [ -e "$BUILDER_DIR" ]; then
    echo "A basic builder directory already existed, so not re-fetched."
    echo "   Directory found at $BUILDER_DIR."
    return 0
  fi
  echo "A basic builder did not exist, so will fetch platform and tools."
  DROP_DIR=$( dirname "$BUILDER_DIR" )
  # Are these as expected? TODO: change comments.
  echo "Drop directory: $DROP_DIR"
  echo "BUILDER_DIR: $BUILDER_DIR"
  EBuilderDir=$DROP_DIR/eclipse.platform.releng.aggregator/eclipse.platform.releng.tychoeclipsebuilder
  if [[ ! -d "${EBuilderDir}" ]]
  then
    echo "EBuilderDir did not exist, so will fetch that first"
    ${SCRIPT_PATH}/getEBuilderForDropDir.sh $DROP_DIR $EBUILDER_HASH
  else
    echo "EBuilderDir already existed, so no need to fetch that"
  fi
  ant -f $EBuilderDir/eclipse/getBaseBuilderAndTools.xml -DWORKSPACE=$DROP_DIR
}

# USAGE: fn-basebuilder-launcher BUILDER_DIR
#   BUILDER_DIR: /shared/eclipse/builds/R4_2_maintenance/org.eclipse.releng.basebuilder_R3_7
fn-basebuilder-launcher ()
{
  checkNArgs $# 1
  if [[ $? != 0 ]]; then return 1; fi
  BUILDER_DIR="$1"; shift
  find "$BUILDER_DIR" -name "org.eclipse.equinox.launcher_*.jar" | tail -1
}

# USAGE: fn-pom-version-report BUILD_ID REPO_DIR BUILD_DIR LOCAL_REPO
#   BUILD_ID: I20121116-0700
#   REPO_DIR: /shared/eclipse/builds/R4_2_maintenance/gitCache/eclipse.platform.releng.aggregator
#   BUILD_DIR: /shared/eclipse/builds/R4_2_maintenance/dirs/M20121120-1747
fn-pom-version-report ()
{
  checkNArgs $# 3
  if [[ $? != 0 ]]; then return 1; fi
  BUILD_ID="$1"; shift
  REPO_DIR="$1"; shift
  BUILD_DIR="$1"; shift
  pushd "$REPO_DIR"
  mkdir -p "$BUILD_DIR"/pom_updates
  git submodule foreach "if (git status -s -uno | grep pom.xml >/dev/null ); then git diff >$BUILD_DIR/pom_updates/\$name.diff; fi "
  pushd "$BUILD_DIR"/pom_updates
  nDiffs=$( ls -1 $BUILD_DIR/pom_updates/*.diff | wc -l )
  # do not create index.html if no diffs to display, as our PHP DL page knows
  # not to display link if index.html is not present.
  if (( $nDiffs > 0 ))
  then
    POM_UPDATES=""
    echo "<html>"  >index.html
    echo "<head>"  >>index.html
    echo "<title>POM version report for $BUILD_ID</title>"  >>index.html
    echo "</head>"  >>index.html
    echo "<body>"  >>index.html
    echo "<h1>POM version report for $BUILD_ID</h1>"  >>index.html
    echo "<p>These repositories need patches to bring their pom.xml files up to the correct version.</p>"  >>index.html
    echo "<ul>"  >>index.html

    for f in *.diff; do
      FNAME=$( basename $f .diff )
      echo "<li><a href=\"$f\">$FNAME</a></li>" >> index.html
      POM_UPDATES="${POM_UPDATES}<li><a href='$f'>$FNAME</a></li>"
    done
    echo "</ul>" >> index.html
    echo "</html>" >> index.html
    # we write to property files, for later use in email message
    fn-write-property POM_UPDATES
  fi
  popd
  popd
}

# USAGE: fn-check-dir-exists DIR_VAR_NAME
#   DIR_VAR_NAME: JAVA_HOME (not, $JAVA_HOME, for better error messages)
#   callers should check for non-zero returned value, which itself is suitable for message,
#   but must be quoted. Such as
#        rc=${fn-check-dir-exists JAVA_HOME)
#        checkForErrorExit "$rc" "$rc"
fn-check-dir-exists ()
{
  checkNArgs $# 1
  if [[ $? != 0 ]]; then return 1; fi
  DIR_VAR_NAME=$1
  if [[ -z "${!DIR_VAR_NAME}" ]]
  then
    echo "DIR_VAR_NAME, ${DIR_VAR_NAME}, must be defined before running this script."
  else
    if [[ ! -d  "${!DIR_VAR_NAME}" ]]
    then
      echo "The directory DIR_VAR_NAME, ${DIR_VAR_NAME} (\"${!DIR_VAR_NAME}\"), must exist before running this script."
    else
      echo 0
    fi
  fi
}

# USAGE: fn-write-property VAR_NAME
#   VAR_NAME: Variable name to write as "variable=value" form
# This script assumes the following variables have been defined and are pointing
# to an appropriate file (see master-build.sh):
# BUILD_ENV_FILE=${buildDirectory}/buildproperties.shsource
# BUILD_ENV_FILE_PHP=${buildDirectory}/buildproperties.php
# BUILD_ENV_FILE_PROP=${buildDirectory}/buildproperties.properties

# Note we always append to file, assuming if doesn't exist yet and will be
# created, and for each build, it won't exist, so will be written fresh for
# each build.

# TODO: Could add some sanity checking of if variable name appropriate
# for various language (e.g. I forget all the rules, but bash variables
# can not start with numerial, PHP variables (or is it Ant) can't have hyphens
# (or is it underscore :), etc. But may need to add some mangling, or warning?
# Similarly, not sure at the moment of what to
# write if value is null/empty. For now will leave empty string, but some might need blank?
# Or literally nothing? Also, unsure of effects of full quoting or if always needed?

fn-write-property ()
{
  checkNArgs $# 1
  if [[ $? != 0 ]]; then return 1; fi
  VAR_NAME=$1
  if [[ -z "${VAR_NAME}" ]]
  then
    echo "VAR_NAME must be passed to this script, $0."
    return 1
  fi

  # bash scripts (export may be overkill ... but, just in case needed)
  echo "export ${VAR_NAME}=\"${!VAR_NAME//\"/\\\"}\"" >> $BUILD_ENV_FILE
  # PHP, suitable for direct "include"
  echo "\$${VAR_NAME} = \"${!VAR_NAME//\"/\\\"}\";" >> $BUILD_ENV_FILE_PHP
  # standard properties file
  echo "${VAR_NAME} = \"${!VAR_NAME//\"/\\\"}\"" >> $BUILD_ENV_FILE_PROP

}

# USAGE: fn-write-property-init
# Must be called (exactly) once before writing properties.
fn-write-property-init ()
{
  checkNArgs $# 0
  if [[ $? != 0 ]]; then return 1; fi
  # nothing really required for bash shsource, but we'll put in some niceties
  echo "#!/usr/bin/env bash" > $BUILD_ENV_FILE
  echo "# properties written for $BUILD_ID" >> $BUILD_ENV_FILE
  # PHP, suitable for direct "include": needs to start and end with <?php ...
  echo "<?php " > $BUILD_ENV_FILE_PHP
  echo "// properties written for $BUILD_ID " >> $BUILD_ENV_FILE_PHP
  # standard properties file: nothing special required
  echo "! properties written for $BUILD_ID" > $BUILD_ENV_FILE_PROP

}

# USAGE: fn-write-property-close
# Must be called (exactly) once when completely finished writing properties.
fn-write-property-close ()
{
  checkNArgs $# 0
  if [[ $? != 0 ]]; then return 1; fi
  # nothing really required for bash shsource, but we'll put in some niceties
  echo "# finished properties for $BUILD_ID" >> $BUILD_ENV_FILE
  # PHP, suitable for direct "include": needs to start and end with <?php ...
  # Note: technically best not to use closing ?> for an 'include'
  echo "// finished properties for $BUILD_ID " >> $BUILD_ENV_FILE_PHP

  # standard properties file: nothing special required
  echo "! finshed properties for $BUILD_ID" >> $BUILD_ENV_FILE_PROP

}

# USAGE: fn-complete-status "message"
# Assumed called while in aggregator directory, so get's its git status,
# then iterates through each submodule for status.
# This is/was intend to debug why "cleanup" does not always clean up/reset everything,
# so if too verbose, can remove in future.
# Message is a quoted string that can be printed out before each status, for
# improved logging.
fn-complete-status ()
{
  checkNArgs $# 1
  if [[ $? != 0 ]]; then return 1; fi
  MESSAGE=$1
  printf "\n\t%s\n\n" "${MESSAGE}"
  git status
  git submodule foreach git status
}

