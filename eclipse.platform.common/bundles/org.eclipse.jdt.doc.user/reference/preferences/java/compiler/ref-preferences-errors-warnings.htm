<!DOCTYPE HTML>
<html lang="en">
<head>
<meta name="copyright" content="Copyright (c) IBM Corporation and others 2000, 2017. This page is made available under license. For full details see the LEGAL in the documentation book that contains this page.">
<meta charset="utf-8">
<title>Java Compile Errors/Warnings Preferences</title>
<link rel="stylesheet" href="../../../../book.css" type="text/css">
<script src="PLUGINS_ROOT/org.eclipse.help/livehelp.js"> </script>
</head>
<body>
<h1>Java Compile Errors/Warnings Preferences</h1>
<p>Indicate your preferences for the Errors/Warnings settings on the <a class="command-link" href='javascript:executeCommand("org.eclipse.ui.window.preferences(preferencePageId=org.eclipse.jdt.ui.preferences.ProblemSeveritiesPreferencePage)")'> <img src="PLUGINS_ROOT/org.eclipse.help/command_link.svg" alt="Opens the Errors/Warnings preference page"> <b> Java &gt; Compiler &gt; Errors/Warnings </b></a> preference page.</p>
<h3>Code Style</h3>
<table class="border">
	<caption>Code style section</caption>
	<tr>
		<th>
		<p>Option</p>
		</th>
		<th>
		<p>Description</p>
		</th>
		<th>
		<p>Default</p>
		</th>
	</tr>
	<tr>
		<td>
		<p>Non-static access to a static member</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever a static field or method is accessed with an expression receiver. A reference to a static member should be qualified with a type name.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Indirect access to a static member</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever a static field or method is indirectly accessed. A static field of an interface should be qualified with the declaring type name.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Unqualified access to instance field</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters a field access which is not qualified (e.g. misses a 'this').</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Access to a non-accessible member of an enclosing type</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it emulates access to a non-accessible member of an enclosing type. Such accesses can have performance implications.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Parameter assignment</p>
		</td>
		<td>
		<p>Assigning a value to a parameter is generally considered poor style programming. When this option is enabled, the compiler will signal such scenario either as an error or a warning.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Non-externalized strings</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning for non externalized String literal (i.e. non tagged with //$NON-NLS-&lt;n&gt;$) or for non externalized String tags which do not belong to a String.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Undocumented empty block</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters an empty block statement with no explaining comment.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Resource not managed via try-with-resource (1.7 or higher)</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning if a local variable holds a value of type 'java.lang.AutoCloseable', and if the method
		'close()' is explicitly invoked on that resource, but the resource is not managed by a try-with-resources block.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Method with a constructor name</p>
		</td>
		<td>
		<p>Naming a method with a constructor name is generally considered poor style programming. When this option is enabled, the compiler will signal such scenario either as an error or a warning.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Method can be static</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning for methods which are private or final and which refer only to static members.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Method can potentially be static</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning for methods which are not private or final and which refer only to static members. Note that methods can be overridden in a subclass, so if you make a "potentially static" method static, this may break existing clients.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
</table>

<h3>Potential Programming Problems</h3>

<table class="border">
	<caption>Potential programming problems section</caption>
	<tr>
		<td>
		<p>Comparing identical values ('x == x')</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning if a comparison is involving identical operands (e.g 'x == x').</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Assignment has no effect (e.g. 'x = x')</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever an assignment has no effect (e.g. 'x = x').</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Possible accidental boolean assignment (e.g. 'if (a = b)')</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters a possible accidental boolean assignment (e.g. 'if (a = b)').</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Boxing and unboxing conversions</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters a boxing or unboxing conversion. Autoboxing may affects performance negatively.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Using a char array in string concatenation</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever a char[] expression is used in String concatenations,</p>
		<code>"hello" + new char[]{'w','o','r','l','d'}</code></td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Inexact type match for vararg arguments</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters an inexact type match for vararg arguments.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Unlikely argument type for collection methods using 'Object'</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or warning when certain well-known Collection methods
		that take an 'Object', e.g. 'Map#get(Object)', are used with an argument type,
		that seems to be not related to the corresponding type argument of the Collection.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Perform strict analysis against the expected type</p>
		</td>
		<td>
		<p>By default, this analysis will apply some heuristics to determine whether two
		types may be related, which can be changed via this option. When enabled, the heuristics will be replaced with strict compatibility checks,
		i.e., each argument that is not strictly compatible with the expected type will trigger an error or warning.</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Unlikely argument type for method equals()</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or warning when 'java.lang.Object#equals(Object)' is used with an argument type,
		that seems to be not related to the receiver's type, or correspondingly when the arguments of 'java.util.Objects#equals(Object, Object)'
		have types that seem to be not related to each other.</p>
		</td>
		<td>
		<p>Info</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Empty statement</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters an empty statement (e.g. a superfluous semicolon).</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Unused object allocation</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning when it encounters an allocated object which is not used, e.g.</p>
		<code>if (name == null)</code><br>
		<code>&nbsp;&nbsp;&nbsp;new IllegalArgumentException();</code><br>
		<br>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr id="switch">
		<td>
		<p>Incomplete 'switch' cases on enum</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters a 'switch' statement which does not contain
		a 'default' case nor case statements for every enum constant of the referenced enum.</p>
		<p>This warning is recommended by the Java Language Specification
		<a href="http://docs.oracle.com/javase/specs/jls/se7/html/jls-14.html#jls-14.11">14.11</a>.
		It helps to ensure that 'switch' statements cover all possible enum values.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr id="missing_case_despite_default">
		<td style="padding-left: 2em;">
		<p>Signal even if 'default' case exists</p>
		</td>
		<td>
		<p>When enabled, the compiler additionally will issue an error or a warning if an enum constant is not covered by a case,
		even if a 'default' case exists.</p>
		<p>This option helps to catch missing case statements when a new enum constant is added.</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>'switch' is missing 'default' case</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning if a 'switch' statement lacks a 'default' case.
		Consequently, a missing 'default' will be flagged even if all possible values are otherwise covered by 'case' statements.</p>
		<p>This option helps to ensure that new 'switch' expression values are handled explicitly, rather than being skipped.
		It can also help to explain compile errors for un-initialized variables after a 'switch' statement: The set of legal values
		can grow in the future, so the variable also needs to be initialized in the 'default' case.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>'switch' case fall-through</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning when a case may be entered by falling through a preceding, non empty case.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Hidden catch block</p>
		</td>
		<td>
		<p>Locally to a try statement, some catch blocks may hide others , e.g.</p>
		<code>try { throw new java.io.CharConversionException();</code><br>
		<code>} catch (java.io.CharConversionException e) {</code><br>
		<code>} catch (java.io.IOException e) {}</code><br>
		<br>
		<p>When enabled, the compiler will issue an error or a warning for hidden catch blocks corresponding to checked exceptions.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>'finally' does not complete normally</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever a 'finally' statement does not complete normally (e.g. contains a return statement).</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Dead code (e.g. 'if (false)')</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning when it encounters dead code (e.g 'if (false)' ).</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr id="resource-leak">
		<td>
		<p>Resource leak</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning if a local variable holds a value of type 'java.lang.AutoCloseable' (compliance &gt;= 1.7) 
	 		or a value of type 'java.io.Closeable' (compliance &lt;= 1.6) and if
	 		flow analysis shows that the method 'close()' is not invoked locally on that value.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Potential resource leak</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning if a local variable holds a value of type 'java.lang.AutoCloseable' (compliance &gt;= 1.7) 
	 		or a value of type 'java.io.Closeable' (compliance &lt;= 1.6) and if 
	 		flow analysis shows that the method 'close()' is not invoked locally on that value for all execution paths.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Serializable class without serialVersionUID</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever a type implementing 'java.io.Serializable' does not contain a serialVersionUID field.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Missing synchronized modifier on inherited method</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning when it encounters an inherited method which is missing the synchronized modifier.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Class overrides 'equals()' but not 'hashCode()'</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning when it encounters a class which overrides 'equals()' but not 'hashCode()'.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
</table>

<h3>Name Shadowing and Conflicts</h3>

<table class="border">
	<caption>Name shadowing and conflicts section</caption>
	<tr>
		<td>
		<p>Field declaration hides another field or variable</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning if a field declaration hides another inherited field.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Local variable declaration hides another field or variable</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning if a local variable declaration hides another field or variable.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Include constructor or setter method parameters</p>
		</td>
		<td>
		<p>When enabled, the compiler additionally will issue an error or a warning if a constructor or setter method parameter hides another field or variable.</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Type parameter hides another type</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning if i.e. a type parameter of an inner class hides an outer type.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Method does not override package visible method</p>
		</td>
		<td>
		<p>A package default method is not visible in a different package, and thus cannot be overridden. When this option is enabled, the compiler will signal such scenario either as an error or a warning.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Interface method conflicts with protected 'Object' method</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever an interface defines a method incompatible with a non-inherited Object method. Until this conflict is resolved, such an interface cannot be implemented, e.g.</p>
		<code>interface I {</code><br>
		<code>&nbsp;&nbsp;&nbsp;int clone();</code><br>
		<code>}</code><br>
		<br>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
</table>

<h3>Deprecated and Restricted API</h3>

<table class="border">
	<caption>Deprecated and restricted API section</caption>
	<tr>
		<td>
		<p>Deprecated API</p>
		</td>
		<td>
		<p>When enabled, the compiler will signal use of deprecated API either as an error or a warning.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Signal use of deprecated API inside deprecated code</p>
		</td>
		<td>
		<p>When enabled, the compiler will signal use of deprecated API inside deprecated code. The severity of the problem is controlled with option "Deprecated API".</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Signal overriding or implementing deprecated method</p>
		</td>
		<td>
		<p>When enabled, the compiler will signal overriding or implementing a deprecated method The severity of the problem is controlled with option "Deprecated API".</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Forbidden reference (access rules)</p>
		</td>
		<td>
		<p>When enabled, the compiler will signal a forbidden reference specified in the access rules.</p>
		</td>
		<td>
		<p>Error</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Discouraged reference (access rules)</p>
		</td>
		<td>
		<p>When enabled, the compiler will signal a discouraged reference specified in the access rules.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
</table>

<h3>Unnecessary Code</h3>

<table class="border">
	<caption>Unnecessary code section</caption>
	<tr>
		<td>
		<p>Value of local variable is not used</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever a local variable is declared but its value is never used within its scope.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Value of method parameter is not used</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever a method parameter is declared but its value is never used within its scope.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Ignore in overriding and implementing methods</p>
		</td>
		<td>
		<p>When enabled, the compiler will not issue an error or a warning whenever a parameter is declared but never used within its scope in a method that overrides or implements another method.</p>
		</td>
		<td>
		<p>On</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Unused type parameter</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning for unused type parameter.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Ignore parameters documented with '@param' tag</p>
		</td>
		<td>
		<p>When enabled, the compiler will not issue an error or a warning whenever an unread parameter is documented with an '@param' tag.</p>
		</td>
		<td>
		<p>On</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Value of exception parameter is not used</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning when a catch clause of a try statement has an exception parameter that is not used in its body.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Unused import</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning for unused import reference.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Unused private member</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever a private member is declared but never used within the same unit.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Unnecessary 'else' statement</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters an unnecessary else statement (e.g. if (condition) return; else doSomething();).</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Unnecessary cast or 'instanceof' operation</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters an unnecessary cast or 'instanceof' operation (e.g. if (object instanceof Object) return;).</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Unnecessary declaration of thrown exception</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters an unnecessary declaration of a thrown exception.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>

	<tr>
		<td style="padding-left: 2em;">
		<p>Ignore in overriding and implementing methods</p>
		</td>
		<td>
		<p>When enabled, the compiler will not issue an error or a warning whenever it encounters an unnecessary declaration of a thrown exception in a method that overrides or implements another method.</p>
		</td>
		<td>
		<p>On</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Ignore exceptions documented with '@throws' or '@exception' tags</p>
		</td>
		<td>
		<p>When enabled, the compiler will not issue an error or a warning whenever an unnecessary declaration of a thrown exception is documented with an '@throws' or '@exception' tag.</p>
		</td>
		<td>
		<p>On</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Ignore 'Exception' and 'Throwable'</p>
		</td>
		<td>
		<p>When enabled, the compiler will not issue an error or a warning whenever it encounters an unnecessary declaration of 'Exception' and 'Throwable' exception</p>
		</td>
		<td>
		<p>On</p>
		</td>
	</tr>	
	<tr>
		<td>
		<p>Unused 'break' or 'continue' label</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters an unused 'break' or 'continue' label.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Redundant super interface</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters a type which
		   explicitly implements an interface that is already implemented by any of its supertypes.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
</table>

<h3>Generic Types</h3>

<table class="border">
	<tr>
		<td>
		<p>Unchecked generic type operation</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters an unchecked generic type operation.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Usage of a raw type</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters a usage of a raw type (e.g. List instead of List&lt;String&gt;).</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Generic type parameter declared with a final type bound</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters a type bound involving a final type.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Redundant Type Arguments (1.7 or higher)</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters an unnecessary type argument in allocation expression.
		Use a diamond operator instead - applicable for levels 1.7 and above.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Ignore unavoidable generic type problems due to raw APIs</p>
		</td>
		<td>
		<p>When enabled, the compiler will ignore generics-related type problems
		that could not have been avoided by the programmer, because a referenced API already contains raw types.
		As an example, a type may be forced to use raw types
		in its method signatures and return types because the methods it overrides from a super type are declared to
		use raw types in the first place.</p>
		<p>When the old API is eventually generified, then most of these problems either go away,
		or you will see a compile error because the type arguments you used are not correct.
		For raw references in method signatures, the raw type problem will reappear.</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
</table>

<h3 id="annotations">Annotations</h3>

<table class="border">
	<tr>
		<td>
		<p>Missing '@Override' annotation</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters a method overriding another implemented method, and the '@Override' annotation is missing.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Include implementations of interface methods (1.6 or higher)</p>
		</td>
		<td>
		<p>When enabled, the compiler will also issue an error or a warning whenever it encounters a method overriding or implementing
		a method declared in an interface, and the '@Override' annotation is missing.<br>
		Note that '@Override' is only allowed on such methods if the compiler compliance level is 1.6 or higher, so this error or
		warning will never appear in 1.5 code.</p>
		</td>
		<td>
		<p>On</p>
		</td>
	</tr>	
	<tr>
		<td>
		<p>Missing '@Deprecated' annotation</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters a type that has a javadoc '@deprecated' tag, but does not have a corresponding Java '@Deprecated' annotation.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Annotation is used as super interface</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters a type implementing an annotation. Although possible, this is considered bad practice.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Unhandled token in '@SuppressWarnings'</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters an unknown token in a '@SuppressWarnings' annotation.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Enable '@SuppressWarnings' annotations</p>
		</td>
		<td>
		<p>When enabled, the compiler will process '@SuppressWarnings' annotations. When disabled, it will act as if all '@SuppressWarnings' annotations were removed.</p>
		<p>See also <a href="../../../../tasks/task-suppress_warnings.htm">Excluding warnings using @SuppressWarnings</a>.</p>
		</td>
		<td>
		<p>On</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Unused '@SuppressWarnings' token</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever it encounters an unused token in a '@SuppressWarnings' annotation.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Suppress optional errors with '@SuppressWarnings'</p>
		</td>
		<td>
		<p>When enabled, the '@SuppressWarnings' annotation will also suppress optional compile errors, i.e. options set to "Error" here.
		Mandatory compile errors cannot be suppressed.</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
</table>

<h3 id="null_analysis">Null Analysis</h3>

<table class="border">
	<tr>
		<td>
		<p>Null pointer access</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning when it encounters that a local variable which is certainly null is dereferenced. Note that the analysis can not find all null pointer accesses, see <strong>Potential null pointer access</strong>.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Potential null pointer access</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning when it encounters that a local variable which may be null is dereferenced. Note that the analysis is fairly conservative, it only considers cases where there is something suspicious.</p>
		<p>The quality of the analysis can be improved by using null-annotations, which can be enabled using the option 
		<b>Enable annotation-based null analysis</b>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Redundant null check</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning whenever a local variable which can not be null is tested for null.</p>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Include 'assert' in null analysis</p>
		</td>
		<td>
		<p>When enabled, the compiler will honor 'assert' statement when doing the null analysis.</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
	<tr>
		<td>
		<p>Enable annotation-based null analysis</p>
		</td>
		<td>
		<p>When enabled, the compiler will interpret annotations @Nullable, @NonNull, and @NonNullByDefault
		as specifying whether or not a given type includes the value 'null'.</p>
		<p>The effect of these analyses is further controlled by the following sub-options.</p>
		<p>See also <a href="../../../../tasks/task-using_null_annotations.htm">Using null annotations</a>.</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
	<tr id="null_spec_violation">
		<td style="padding-left: 2em;">
		<p>Violation of null specification</p>
		</td>
		<td>
		<p>Depending on this option, the compiler will issue either an error or a warning whenever one of the following situations is detected:</p> 
		<ol>
		<li>A method declared with a nonnull annotation returns a <em>nullable</em> expression.</li> 
		<li>A <em>nullable</em> expression is passed as an argument in a method call where the corresponding parameter of the called method is declared with a nonnull annotation.</li> 
		<li>A <em>nullable</em> expression is assigned to a local variable that is declared with a nonnull annotation.</li> 
		<li>A method that overrides an inherited method declared with a nonnull annotation tries to relax that contract by specifying a nullable annotation (prohibition of contravariant return).</li> 
		<li>A method that overrides an inherited method which has a nullable declaration for at least one of its parameters, tries to tighten that null contract by specifying a nonnull annotation for its corresponding parameter (prohibition of covariant parameters).</li>
		</ol>
		<p>In the above an expression is considered as <em>nullable</em> if
	 	either it is statically known to evaluate to the value <code>null</code>, or if it is
	 	declared with a nullable annotation.</p>
		</td>
		<td>
		<p>Error</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Conflict between null annotations and null inference</p>
		</td>
		<td>
		<p>Depending on this option, the compiler will issue either an error or a warning whenever one of the following situations is detected:</p>
		<ol>
		<li>A method declared with a nonnull annotation returns an expression that is statically known to evaluate to a null value on some flow.</li> 
		<li>An expression that is statically known to evaluate to a null value on some flow is passed as an argument in a method call where the corresponding parameter of the called method is declared with a nonnull annotation. </li> 
		<li>An expression that is statically known to evaluate to a null value on some flow is assigned to a local variable that is declared with a nonnull annotation.</li> 
		</ol> 
		</td>
		<td>
		<p>Error</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Unchecked conversion from non-annotated type to @NonNull type</p>
		</td>
		<td>
		<p>Depending on this option, the compiler will issue either an error or a warning whenever one of the following situations is detected:</p>
		<ol>
		<li>A method declared with a nonnull annotation returns an expression for which insufficient nullness information is available for statically proving that no flow will pass a null value at runtime. </li> 
		<li>An expression for which insufficient nullness information is available for statically proving that it will never evaluate to a null value at runtime is passed as an argument in a method call where 
		the corresponding parameter of the called method is declared with a nonnull annotation. </li> 
		<li>An expression for which insufficient nullness information is available for statically proving that it will never evaluate to a null value at runtime is assigned to a local variable that is declared 
		with a nonnull annotation. </li> 
		</ol> 
		<p>Unchecked conversion is usually a consequence of using other unannotated variables or methods.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr id="pessimistic_analysis">
		<td style="padding-left: 2em;">
		<p>Problems detected by pessimistic analysis for free type variables</p>
		</td>
		<td>
		<p>Unless set to "Ignore", type variables not affected by any explicit null annotation are 
		<a href="../../../../tasks/task-using_null_type_annotations.htm#pessimistic_analysis">pessimistically analysed</a>
		in two directions: When reading a value of this type, it is assumed to be nullable.
		When this type appears as the required type (i.e., at the left hand side of an assignment or variable initialization,
		or as the method return type against which a return statement is being checked)
		the type is considered to require the nonnull property.</p>
		<p>Problems reported due to this pessimistic analysis are reported with the level given in this option.</p>
		<p>This option is only relevant when using <a href="../../../../tasks/task-using_null_type_annotations.htm">null type annotations</a>.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr id="unsafe_interpretation_generic_legacy">
		<td style="padding-left: 2em;">
		<p>Unsafe '@Nonnull' interpretation of free type variable from library</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning against a method call if all of the following hold:</p>
		<ul>
			<li>The method's declared return type is a type variable without any null annotation.</li>
			<li>For the given invocation this type variable is substituted with a nonnull type.</li>
			<li>The type declaring the method is provided by a third-party library.</li>
			<li>No null annotations exist for this library type, neither in its class file nor using external annotations.</li>
		</ul>
		<p>This particular situation leverages the option to consistently substitute all occurrences of a type variable with a nonnull type,
		but it bears the risk that the library type may not be aware of null annotations thus lacking a necessary @Nullable annotation
		for a particular occurrence of a type variable.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	<tr>
		<td style="padding-left: 2em;">
		<p>Redundant null annotation</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning when a non-null annotation is applied although the same effect is already achieved by a default applicable at the current location. 
		Such a default may be set by using the @NonNullByDefault annotation.</p>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr id="nonnull_annotation_dropped">
		<td style="padding-left: 2em;">
		<p>'@NonNull' parameter not annotated in overriding method</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning against a parameter of a method that overrides an inherited method if all of the following hold:</p>
		<ul>
		<li>The overridden method declares the corresponding parameter as non-null.</li>
		<li>The parameter in the overriding method has no null annotation.</li>
		<li>The overriding method is not affected by a nullness default.</li>
		<li>Inheritance of null annotations is disabled.</li>
		</ul>
		</td>
		<td>
		<p>Warning</p>
		</td>
	</tr>
	<tr>
		<td style="padding-left: 2em;">
		<p>Missing '@NonNullByDefault' annotation on package</p>
		</td>
		<td>
		<p>When enabled, the compiler will issue an error or a warning in the following cases:</p>
		<ol>
		<li>When a package does not contain a default nullness annotation, as a result of missing package-info.java 
	 	or missing default nullness annotation in package-info.java.</li>
	 	<li>When a type inside a default package does not contain a default nullness annotation.</li>
		</ol>
		</td>
		<td>
		<p>Ignore</p>
		</td>
	</tr>
	<tr id="null_annotation_names">
		<td style="padding-left: 2em;">
		<p>Use default annotations for null specifications</p>
		</td>
		<td>
		<p>When enabled, the compiler will use the default set of annotations for null specifications. These annotations are included in the Eclipse SDK in the
		<b>org.eclipse.jdt.annotation</b> bundle.</p>
		<p>You can specify different annotation names to use in your projects, but be aware that the Eclipse compiler only supports the semantics
		specified in the default annotations:</p>
		<ul>
			<li><b>org.eclipse.jdt.annotation.Nullable</b>: A fully qualified name of a Java annotation type, which when applied to a type in a method signature, variable declaration or field declaration, 
				will be interpreted as a specification that null is a legal value in that position.<br>
				Currently supported positions are: method parameters, method return type, local variables and fields.
			</li>
			<li><b>org.eclipse.jdt.annotation.NonNull</b>: A fully qualified name of a Java annotation type, which when applied to a type in a method signature, variable declaration or field declaration, 
				will be interpreted as a specification that null is <b>not</b> a legal value in that position.<br>
				Currently supported positions are: method parameters, method return type, local variables and fields.
			</li>
			<li>
				<b>org.eclipse.jdt.annotation.NonNullByDefault</b>: A fully qualified name of a Java annotation type. When applied to an element without an annotation argument, 
				all unannotated types in method signatures and field declarations within the annotated element will be treated as if they were specified with the non-null annotation.<br>
				Only when using the default annotation type <code>org.eclipse.jdt.annotation.NonNullByDefault</code>, also the opposite effect is supported:
				When the annotation is applied with the constant 'false' as its argument (or '{}' in the case of type annotations),
				all corresponding defaults at outer scopes will be canceled for the annotated element.
			</li>
		</ul>
		<p>The compiler supports exactly one <em>primary</em> set of annotation types for null specification. Additionally, an arbitrary number of <em>secondary</em> annotation types
		can be configured to carry the same semantics. Secondary annotation types are supported for the sole purpose of interfacing with 3rd party code that is already specified
		using other null annotations than the primary annotations types of the current project.</p>
		</td>
		<td>
		<p>On</p>
		</td>
	</tr>
	<tr id="inherit_null_annotations">
		<td style="padding-left: 2em;">
		<p>Inherit null annotations</p>
		</td>
		<td>
		<p>When enabled, the compiler will check for each method without any explicit null annotations:
	 	  If it overrides a method which has null annotations, it will treat the
	 	  current method as if it had the same annotations as the overridden method.</p>
	 	  <p>Annotation inheritance will use the <em>effective</em> nullness of the overridden method
	 		after transitively applying inheritance and after applying any default nullness
	 		at the site of the overridden method.</p>
	 	  <p>If different implicit null annotations (from a nonnull default and/or overridden methods) are applicable
	 		to the same type in a method signature, this is flagged as an error 
	 		and an explicit null annotation must be used to disambiguate.</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
	<tr id="syntactic_null_analysis_for_fields">
		<td style="padding-left: 2em;">
		<p>Enable syntactic null analysis for fields</p>
		</td>
		<td>
		<p>When enabled, the compiler will detect certain syntactic constellations where a null related warning against a field reference 
		would normally be raised but can be suppressed at low risk given that the same field reference was known to be non-null immediately before.
		When using this option please see <a href="../../../../tasks/task-using_null_annotations.htm#syntactic_analysis">these hints</a>.</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
	<tr id="external_annotations_from_all_locations">
		<td style="padding-left: 2em;">
		<p>Search for external annotations in all build path locations</p>
		</td>
		<td>
		<p>When enabled, the compiler will search all build path locations for
		<a href="../../../../tasks/task-using_external_null_annotations.htm">external annotations</a> to be considered
		during annotation-based null analysis. This strategy will be applied to every class file found during compilation.
		<br>The default is to search only those locations that are specified using the "external annotations" property
		of each individual build path entry and apply any annotations found only to classes in that corresponding build path entry.</p>
		</td>
		<td>
		<p>Off</p>
		</td>
	</tr>
</table>

<p>When <strong>Treat above errors like fatal compile errors</strong> is enabled, all generated errors, fatal or configurable, lead to non-executable code.
If disabled, then your code can be executed as long as it has no fatal error (syntax error, type error, or any error according to the Java Language Specification).</p>

<h3 class="related">Related Concepts</h3>
<a href="../../../../../org.eclipse.platform.doc.user/concepts/cprbview.htm">Problems View</a><br>
<a href="../../../../concepts/concept-quickfix-assist.htm">Quick Fix</a><br>
<a href="../../../../concepts/concept-java-builder.htm">Java builder</a><br>
<a href="../../../../tasks/task-suppress_warnings.htm">Excluding warnings using @SuppressWarnings</a>
</body>
</html>
