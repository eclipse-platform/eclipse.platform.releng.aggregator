// Constants read by job creation
private static final _JOB_DISPLAY_NAME = 'Prepare Next Development Cycle'
private static final _JOB_DESCRIPTION = 'Perform all steps to prepare the next development cycle of Eclipse.'

def releaseEvents = [ M1: 'Milestone 1', M2: 'Milestone 2', M3: 'Milestone 3', RC1: 'Release Candidate 1', RC2: 'Release Candidate 2', GA: 'Release' ]

pipeline {
	options {
		timestamps()
		timeout(time: 120, unit: 'MINUTES')
		buildDiscarder(logRotator(numToKeepStr:'5'))
		skipDefaultCheckout()
	}
	parameters {
		booleanParam(name: 'DRY_RUN', defaultValue: true, description: '''\
			If enabled, the final publication of all changes is skipped respectivly all changes at the download-server happen in a 'try-out' area at https://download.eclipse.org/eclipse/try-outs/.
			This area is cleaned on each dry-run and should be cleaned after a try-out session is completed.
			Useful for debugging and to very that the pipeline behaves as intended.
		''')
		string(name: 'NEXT_RELEASE_VERSION', trim: true, description: 'Version of the release to prepare, for example: 4.37')
		string(name: 'PREVIOUS_RELEASE_CANDIDATE_ID', trim: true, description: 'Id of the current release-candiate for the previous release. For example: S-4.36RC2-202505281830')
		string(name: 'NEXT_SIMREL_NAME', trim: true, description: 'The name of the Simultanious Release that is targeted by the prepared release. Value is in the format yyyy-mm, for example: 2026-03')
		string(name: 'NEXT_JAVA_RELEASE_DATE', trim: true, description: '''\
			Release date of the next Java version, if it is released shortly after the Eclipse release
			(i.e. shortly after the <em>GA_DATE</em> specified above, <b>usual for odd release versions</b>), else left blank (<b>usual for even releases</b>).
			Value is in the format yyyy-mm-dd, for example: 2025-09-16
		''')
	}
	agent {
		label 'ubuntu-2404'
	}
	tools {
		jdk 'temurin-jdk21-latest'
		maven 'apache-maven-latest'
	}
	//Parameters are defined in the job definition
	stages {
		stage('Process Input') {
			steps {
				script {
					echo "DRY_RUN: ${DRY_RUN}"
					echo "NEXT_RELEASE_VERSION: ${NEXT_RELEASE_VERSION}"
					def nextVersionMatcher = "${NEXT_RELEASE_VERSION}" =~ /(?<major>\d+)\.(?<minor>\d+)/
					if (!nextVersionMatcher.matches()) {
						error "Unexpected format for NEXT_RELEASE_VERSION: ${NEXT_RELEASE_VERSION}"
					}
					assignEnvVariable('NEXT_RELEASE_VERSION_MAJOR', nextVersionMatcher.group('major'))
					assignEnvVariable('NEXT_RELEASE_VERSION_MINOR', nextVersionMatcher.group('minor'))
					nextVersionMatcher = null // release matcher as it's not serializable
					
					echo "PREVIOUS_RELEASE_CANDIDATE_ID: ${PREVIOUS_RELEASE_CANDIDATE_ID}"
					def buildPropertiesTxt = sh(script: "curl --fail https://download.eclipse.org/eclipse/downloads/drops4/${PREVIOUS_RELEASE_CANDIDATE_ID}/buildproperties.txt", returnStdout: true)
					def buildProperties = readProperties(text: buildPropertiesTxt)
					assignEnvVariable('IS_JAVA_RELEASE_IMMINENT', !buildProperties.NEXT_JAVA_RELEASE_DATE.replace('"','').isEmpty()) // Remove surrounding quotes
					
					def previousIdMatcher = null
					if ((previousIdMatcher = "${PREVIOUS_RELEASE_CANDIDATE_ID}" =~ /(?<type>[SR])-(?<major>\d+)\.(?<minor>\d+)(\.(?<service>\d+))?(?<checkpoint>(M|RC)\d+[a-z]?)?-(?<date>\d{8})(?<time>\d{4})/).matches()) {
						def checkpoint = previousIdMatcher.group('checkpoint')
						assignEnvVariable('PREVIOUS_RELEASE_VERSION_MAJOR', previousIdMatcher.group('major'))
						assignEnvVariable('PREVIOUS_RELEASE_VERSION_MINOR', previousIdMatcher.group('minor'))
						assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_TAG', "${PREVIOUS_RELEASE_VERSION_MAJOR}.${PREVIOUS_RELEASE_VERSION_MINOR}${checkpoint}")
						def previousServiceVersion = previousIdMatcher.group('service') ?: '0'
						assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_GIT_TAG', "${previousIdMatcher.group('type')}${PREVIOUS_RELEASE_VERSION_MAJOR}_${PREVIOUS_RELEASE_VERSION_MINOR}${(checkpoint || previousServiceVersion != '0') ? ('_' + previousServiceVersion) : ''}${checkpoint ? ('_' + checkpoint) : ''}")
						
					} else if ((previousIdMatcher = "${PREVIOUS_RELEASE_CANDIDATE_ID}" =~ /I(?<date>\d{8})-(?<time>\d{4})/).matches()) {
						assignEnvVariable('PREVIOUS_RELEASE_VERSION_MAJOR', buildProperties.STREAMMajor.replace('"','')) // Remove surrounding quotes
						assignEnvVariable('PREVIOUS_RELEASE_VERSION_MINOR', buildProperties.STREAMMinor.replace('"','')) // Remove surrounding quotes
						assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_TAG', "${PREVIOUS_RELEASE_CANDIDATE_ID}")
						assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_GIT_TAG', "${PREVIOUS_RELEASE_CANDIDATE_ID}")
						
					} else {
						error "Unexpected format for PREVIOUS_RELEASE_CANDIDATE_ID: ${PREVIOUS_RELEASE_CANDIDATE_ID}"
					}
					assignEnvVariable('PREVIOUS_RELEASE_VERSION', "${PREVIOUS_RELEASE_VERSION_MAJOR}.${PREVIOUS_RELEASE_VERSION_MINOR}")
					assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_I_BUILD', "I${previousIdMatcher.group('date')}-${previousIdMatcher.group('time')}")
					previousIdMatcher = null // release matcher as it's not serializable
					
					echo "NEXT_SIMREL_NAME: ${NEXT_SIMREL_NAME}"
					def simRelMatcher = "${NEXT_SIMREL_NAME}" =~ /(?<year>\d{4})-(?<month>\d{2})/
					if (!simRelMatcher.matches()) {
						error "Unexpected format for NEXT_SIMREL_NAME: ${NEXT_SIMREL_NAME}"
					}
					assignEnvVariable('NEXT_RELEASE_YEAR', simRelMatcher.group('year'))
					assignEnvVariable('NEXT_RELEASE_MONTH', simRelMatcher.group('month'))
					assignEnvVariable('NEXT_RELEASE_NAME', "${NEXT_SIMREL_NAME}")
					simRelMatcher = null // release matcher as it's not serializable
					
					def simRelDatesRaw = sh(script: "curl --fail https://raw.githubusercontent.com/eclipse-simrel/.github/refs/heads/main/wiki/SimRel/${NEXT_SIMREL_NAME}_dates.json", returnStdout: true)
					def simRelDates = readJSON(text: simRelDatesRaw)
					def eclipseReleaseDates = releaseEvents.collectEntries{ name, _ ->
						def date = parseDate(simRelDates[name]).minusDays(name == 'GA' ? 0 : 7) // All Eclipse-TLPs have offset -7 days
						assignEnvVariable("${name}_DATE", date)
						return [name, date]
					}
					assignEnvVariable('MAINTENANCE_BRANCH', "R${PREVIOUS_RELEASE_VERSION_MAJOR}_${PREVIOUS_RELEASE_VERSION_MINOR}_maintenance")
					
					// Compute new build schedule
					def now = java.time.LocalDate.now()
					def rcEnd = eclipseReleaseDates.RC2.minusDays(2) // Wednesday before RC2 is the last planned I-build and the cron-triggers should stop after
					assignEnvVariable('I_BUILD_SCHEDULE', createCronPattern(now, rcEnd, 18, '*').trim())
					
					echo "NEXT_JAVA_RELEASE_DATE: ${NEXT_JAVA_RELEASE_DATE}"
					def yBuildSchedule = null
					if ("${NEXT_JAVA_RELEASE_DATE}".isEmpty()) {
						yBuildSchedule = createCronPattern(now, rcEnd, 10, '2,4,6')
					} else {
						// Java releases soon after the Eclipse release, therefore schedule Y-builds daily within the 'Java RC phase'
						def javaReleaseDate = parseDate("${NEXT_JAVA_RELEASE_DATE}")
						def javaRCStart = javaReleaseDate.minusDays(7)
						def javaRCEnd = javaReleaseDate.plusDays(2)
						if (javaRCStart.monthValue != javaRCEnd.monthValue) {
							// If this is encountered, enhance the logic to handle 'java RC' phases ranging more than one month
							error "Java release is not in the middle of a month"
						}
						yBuildSchedule = createCronPattern(now, javaRCStart, 10, '2,4,6') + """\
						0 10 ${javaRCStart.dayOfMonth}-${javaRCEnd.dayOfMonth} ${javaRCStart.monthValue} *
						""".stripIndent()
					}
					assignEnvVariable('Y_BUILD_SCHEDULE', yBuildSchedule.trim())
				}
			}
		}
		stage('Checkout SCM') {
			steps {
				checkout scm
				script { // Always load the script from the very same state this pipeline is loaded (to ensure consistency)
					utilities = load "JenkinsJobs/shared/utilities.groovy"
					utilities.setDryRun(params.DRY_RUN)
					githubAPI = load "JenkinsJobs/shared/githubAPI.groovy"
					githubAPI.setDryRun(params.DRY_RUN)
				}
				sh '''#!/bin/bash -xe
					git submodule update --init --recursive --remote
					git config --global user.email 'releng-bot@eclipse.org'
					git config --global user.name 'Eclipse Releng Bot'
					
					# Create maintenance branch (at RC) and checkout master (to allow switching branches)
					function createBranches() {
						git checkout -B master HEAD
						git fetch origin tag "${PREVIOUS_RELEASE_CANDIDATE_GIT_TAG}"
						git branch ${MAINTENANCE_BRANCH} ${PREVIOUS_RELEASE_CANDIDATE_GIT_TAG}
						git reflog show master
						git reflog show ${MAINTENANCE_BRANCH}
					}
					createBranches
					export -f createBranches
					git submodule foreach 'createBranches'
				'''
			}
		}
		stage('Update Maven Version') {
			steps {
				sh '''
					mvn org.eclipse.tycho:tycho-versions-plugin:set-version \
						-DnewVersion=${NEXT_RELEASE_VERSION}.0-SNAPSHOT
					mvn -f eclipse-platform-parent/pom.xml tycho-versions:set-property \
						-Dproperties=releaseVersion,releaseYear,releaseMonth \
						-DnewReleaseVersion=${NEXT_RELEASE_VERSION} \
						-DnewReleaseYear=${NEXT_RELEASE_YEAR} \
						-DnewReleaseMonth=${NEXT_RELEASE_MONTH}
				'''
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/platform.product', [
					"eclipse/updates/${PREVIOUS_RELEASE_VERSION}" : "eclipse/updates/${NEXT_RELEASE_VERSION}",
					/releases\/20\d\d-\d\d" name="20\d\d-\d\d"/ : /releases\/${NEXT_RELEASE_NAME}" name="${NEXT_RELEASE_NAME}"/,
				])
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/sdk.product', [
					"eclipse/updates/${PREVIOUS_RELEASE_VERSION}" : "eclipse/updates/${NEXT_RELEASE_VERSION}",
					/releases\/20\d\d-\d\d" name="20\d\d-\d\d"/ : /releases\/${NEXT_RELEASE_NAME}" name="${NEXT_RELEASE_NAME}"/,
				])
				sh '''
					git commit --all --message "Prepare Release ${NEXT_RELEASE_VERSION}"
					git submodule foreach 'git commit --all --message "Update release version for ${NEXT_RELEASE_VERSION}" & echo done'
				'''
			}
		}
		stage('Update build scripts') {
			steps {
				replaceAllInFile('cje-production/buildproperties.txt', [
					"RELEASE_VER=\".*\"" : "RELEASE_VER=\"${NEXT_RELEASE_VERSION}\"",
					"STREAM=\".*\"" : "STREAM=\"${NEXT_RELEASE_VERSION}.0\"",
					"STREAMMajor=\".*\"" : "STREAMMajor=\"${NEXT_RELEASE_VERSION_MAJOR}\"",
					"STREAMMinor=\".*\"" : "STREAMMinor=\"${NEXT_RELEASE_VERSION_MINOR}\"",
					"ECLIPSE_RUN_REPO=\".*\"" : "ECLIPSE_RUN_REPO=\"https://download.eclipse.org/eclipse/updates/${NEXT_RELEASE_VERSION}-I-builds/\"",
					"NEXT_JAVA_RELEASE_DATE=\".*\"" : "NEXT_JAVA_RELEASE_DATE=\"${NEXT_JAVA_RELEASE_DATE}\"",
				])
				replaceInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/platform.p2.inf', [
					"${PREVIOUS_RELEASE_VERSION} Release" : "${NEXT_RELEASE_VERSION} Release",
				])
				replaceInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/sdk.p2.inf', [
					"${PREVIOUS_RELEASE_VERSION} Release" : "${NEXT_RELEASE_VERSION} Release",
				])
				replaceInFile('eclipse.platform.releng/features/org.eclipse.platform-feature/rootfiles/.eclipseproduct', [
					"version=${PREVIOUS_RELEASE_VERSION}.0" : "version=${NEXT_RELEASE_VERSION}.0",
				])
				replaceInFile('production/testScripts/configuration/streamSpecific.properties', [
					"for ${PREVIOUS_RELEASE_VERSION}.0 builds" : "for ${NEXT_RELEASE_VERSION}.0 builds",
				])
				script {
					utilities.modifyJSON('JenkinsJobs/buildConfigurations.json') { builds ->
						// Create I-build for new stream and move previous I-build to maintenance branch to allow late re-spins
						builds.I.streams["${NEXT_RELEASE_VERSION}"] = [ branch: 'master', schedule: env.I_BUILD_SCHEDULE ]
						builds.I.streams["${PREVIOUS_RELEASE_VERSION}"].branch = env.MAINTENANCE_BRANCH
						builds.I.streams["${PREVIOUS_RELEASE_VERSION}"].schedule = '' // schedule should already be inactive, but clear it to be sure
						
						//Create Y-build for new stream
						builds.Y.streams["${NEXT_RELEASE_VERSION}"] = [ branch: 'master', disabled: env.IS_JAVA_RELEASE_IMMINENT, schedule: env.Y_BUILD_SCHEDULE ]
						// If a new Java version is released shortly after the previous release, that Java release will happen in the next days from the point when this is executed.
						// In that case Y-builds for the old stream continue on maintenance branch (with pre-defined schedule) to provide P-builds upon Java release.
						// Then the Y-build for the new stream is initially disabled and enabled manually later, when the beta branch for the subsequent Java release is set up.
						// If no Java release is scheduled soon, the old Y-build stream will just be dormat (like the old I-build), but don't reset its schedule to not overwrite it in the other case.
						builds.Y.streams["${PREVIOUS_RELEASE_VERSION}"].branch = env.MAINTENANCE_BRANCH
					}
				}
				
				gitCommitAllExcludingSubmodules("Update versions to ${NEXT_RELEASE_VERSION} in build scripts")
			}
		}
		stage('Move previous version to current RC') {
			steps {
				sh '''
					mvn -f eclipse-platform-parent/pom.xml tycho-versions:set-property \
						-Dproperties=previous-release.baseline \
						"-DnewPrevious-release.baseline=https://download.eclipse.org/eclipse/updates/${PREVIOUS_RELEASE_VERSION}-I-builds/${PREVIOUS_RELEASE_CANDIDATE_I_BUILD}/"
				'''
				replaceAllInFile('cje-production/buildproperties.txt', [
					'PREVIOUS_RELEASE_VER=".*"' : "PREVIOUS_RELEASE_VER=\"${PREVIOUS_RELEASE_CANDIDATE_TAG}\"",
					'PREVIOUS_RELEASE_REPO_ID=".*"' : "PREVIOUS_RELEASE_REPO_ID=\"${PREVIOUS_RELEASE_VERSION}-I-builds\"",
					'BASEBUILD_ID=".*"' : "BASEBUILD_ID=\"${PREVIOUS_RELEASE_CANDIDATE_I_BUILD}\"",
					'PREVIOUS_RELEASE_ID=".*"' : "PREVIOUS_RELEASE_ID=\"${PREVIOUS_RELEASE_CANDIDATE_ID}\"",
				])
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse-junit-tests/src/main/resources/equinoxp2tests.properties', [
					'eclipse-platform-\\d+.\\d+-' : "eclipse-platform-${PREVIOUS_RELEASE_CANDIDATE_TAG}-",
					'org.eclipse.equinox.p2.tests.last.release.build.repo=.*' : "org.eclipse.equinox.p2.tests.last.release.build.repo=https://download.eclipse.org/equinox/drops/${PREVIOUS_RELEASE_CANDIDATE_ID}/",
				])
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse-junit-tests/src/main/resources/label.properties', [
					'previousReleaseVersion=.*' : "previousReleaseVersion=${PREVIOUS_RELEASE_CANDIDATE_TAG}",
				])
				replaceAllInFile('production/testScripts/configuration/streamSpecific.properties', [
					'previousReleaseLocation=.*' : 'previousReleaseLocation=https://\\${DOWNLOAD_HOST}/eclipse/downloads/drops4/' + PREVIOUS_RELEASE_CANDIDATE_ID + '/',
					'previousReleaseVersion=.*' : "previousReleaseVersion=${PREVIOUS_RELEASE_CANDIDATE_TAG}",
					'previousReleaseVersionRepo=.*' : "previousReleaseVersionRepo=${PREVIOUS_RELEASE_VERSION}-I-builds",
				])
				
				gitCommitAllExcludingSubmodules("Move previous version to ${PREVIOUS_RELEASE_CANDIDATE_TAG} in build scripts")
			}
		}
		stage('Clear Qualifier-update files') {
			steps {
				dir('eclipse.platform.common/bundles') {
					sh '''
						# Clear content of all forceQualifierUpdate files in this directory
						for file in */forceQualifierUpdate.txt; do
							> "$file"
						done
						# Commit cleared files, if there was content to remove
						if [ -n "$(git diff --shortstat .)" ] ; then
							git commit --message "Clean forceQualifierUpdate files of doc bundles for ${NEXT_RELEASE_VERSION} development" .
						else
							echo 'The forceQualifierUpdate files of all doc bundles are already empty. Nothing to do.'
						fi
					'''
				}
			}
		}
		stage('Apply individual updates') {
			environment {
				UPDATE_SCRIPT = 'prepareNextDevCycle.sh'
			}
			steps {
				sh '''
					git submodule foreach 'if [ -f ${UPDATE_SCRIPT} ]; then chmod +x ./${UPDATE_SCRIPT} && ./${UPDATE_SCRIPT}; fi'
				'''
			}
		}
		stage('Prepare maintenance branch') {
			steps {
				// Apply the following changes at a preparation branch, starting at the maintenance branch (to create a PR later)
				sh 'git checkout -b prepareMaintenance ${MAINTENANCE_BRANCH}'
				
				script {
					utilities.modifyJSON('JenkinsJobs/buildConfigurations.json') { builds ->
						builds.values().each{ buildType ->
							def build = buildType.streams["${PREVIOUS_RELEASE_VERSION}"]
							build.branch = env.MAINTENANCE_BRANCH
							build.schedule = ''
						}
						builds.I.branchLabel = env.MAINTENANCE_BRANCH
					}
				}
				replaceInFile('JenkinsJobs/Builds/dockerImages.jenkinsfile', [
					'-b master' : "-b ${MAINTENANCE_BRANCH}",
				])
				replaceInFile('cje-production/buildproperties.txt', [
					'BRANCH="master"' : "BRANCH=\"${MAINTENANCE_BRANCH}\"",
				])
				replaceInFile('cje-production/streams/repositories_java25.txt', [
					': master' : ": ${MAINTENANCE_BRANCH}",
				])
				replaceInFile('cje-production/streams/repositories_master.txt', [
					': master' : ": ${MAINTENANCE_BRANCH}",
				])
				sh "mv cje-production/streams/repositories_master.txt cje-production/streams/repositories_${MAINTENANCE_BRANCH}.txt"
				
				gitCommitAllExcludingSubmodules("Move ${PREVIOUS_RELEASE_VERSION}-I builds to ${MAINTENANCE_BRANCH} branch")
				
				// Switch back to master for subsequent parts of this pipeline
				sh 'git checkout master'
			}
		}
		stage('Validate and list changes') {
			steps {
				sh '''
					function printLatestGitHistory() {
						git log origin/master..master --patch-with-stat --summary
					}
					printLatestGitHistory
					export -f printLatestGitHistory
					git submodule foreach 'printLatestGitHistory'
					
					echo 'Print history of maintenance branch'
					git log refs/tags/${PREVIOUS_RELEASE_CANDIDATE_GIT_TAG}..prepareMaintenance --patch-with-stat --summary
				'''
				// Run simple clean build to verify that at least all parent versions are updated correctly
				sh 'mvn clean'
				// search for leftover occurrences of the previous release version
				sh '''#!/bin/bash -e
					matchingFiles=$(grep --recursive --files-with-matches \
						--include pom.xml \
						--include MANIFEST.MF \
						--include feature.xml \
						--include \\*.product \
						--include \\*.sh \
						--fixed-strings "${PREVIOUS_RELEASE_VERSION}")
					# The eclipse-platform-parent/pom.xml contains the previous version in the baseline repository variable
					if [[ -z "${matchingFiles}" ]] || [[ "${matchingFiles}" == 'eclipse-platform-parent/pom.xml' ]]; then
						echo "No unexpected references to previous version ${PREVIOUS_RELEASE_VERSION} found."
						exit 0
					else
						echo "References to previous version ${PREVIOUS_RELEASE_VERSION} found:"
						for f in ${matchingFiles}; do
							echo "In file ${f}"
							grep "${PREVIOUS_RELEASE_VERSION}" "${f}"
						done
						exit 1
					fi
				'''
			}
		}
		stage ('Create and update Stream Repos') {
			when {
				not { expression { params.DRY_RUN } }
			}
			steps {
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/${NEXT_RELEASE_VERSION}-I-builds"),
					string(name: 'repositoryName', value: "Eclipse ${NEXT_RELEASE_VERSION} integration builds"),
					string(name: 'add', value: "https://download.eclipse.org/eclipse/updates/${PREVIOUS_RELEASE_VERSION}-I-builds/${PREVIOUS_RELEASE_CANDIDATE_I_BUILD}/")
					// Size-limit is not relevant, the repository is initially empty.
				]
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/${NEXT_RELEASE_VERSION}-Y-builds"),
					string(name: 'repositoryName', value: "Eclipse ${NEXT_RELEASE_VERSION} Beta Java builds")
				]
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/${NEXT_RELEASE_VERSION}"),
					string(name: 'repositoryName', value: "Eclipse ${NEXT_RELEASE_VERSION} release")
				]
				// Update generic composite repositories for I/Y-builds (clearing all previous children)
				// Note: The stream number is not in the 'name', because once a 'name' is defined in Eclipse's UI, it does not change.
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/I-builds"),
					string(name: 'repositoryName', value: "Eclipse latest integration builds"),
					string(name: 'sizeLimit', value: '1'), // Clear all previous children
					string(name: 'add', value: "https://download.eclipse.org/eclipse/updates/${NEXT_RELEASE_VERSION}-I-builds/"),
				]
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/Y-builds"),
					string(name: 'repositoryName', value: "Eclipse latest Beta Java builds"),
					string(name: 'sizeLimit', value: '1'), // Clear all previous children
					string(name: 'add', value: "https://download.eclipse.org/eclipse/updates/${NEXT_RELEASE_VERSION}-Y-builds/"),
				]
			}
		}
		stage('Deploy parent-pom and SDK-target') {
			// Deploy new parent first to ensure it's available when PRs for submodule updates are created.
			environment {
				GOAL ="${ params.DRY_RUN ? 'install' : 'deploy' }"
			}
			steps {
				sh '''
					mvn clean ${GOAL} -f eclipse-platform-parent/pom.xml
					mvn clean ${GOAL} -f eclipse.platform.releng.prereqs.sdk/pom.xml
				'''
			}
		}
		stage('Push preparation branches') {
			steps {
				script {
					utilities.runHereAndForEachGitSubmodule{
						utilities.gitPushBranch('master', "prepare-R${NEXT_RELEASE_VERSION}")
						utilities.gitPushBranch("${MAINTENANCE_BRANCH}", "${MAINTENANCE_BRANCH}")
					}
					// Push preparation of the maintenance to a separate branch (not directly to the maintenance branch),
					// to enable creating a PR against the maintenance branch from it.
					utilities.gitPushBranch('prepareMaintenance', "prepare-${MAINTENANCE_BRANCH}")
				}
			}
		}
		stage('Create preparation Pull-Requests') {
			steps {
				script {
					def prHeadline = "Prepare ${NEXT_RELEASE_VERSION} development"
					def prBranch = "prepare-R${NEXT_RELEASE_VERSION}"
					def aggregatorPreparationPR = githubAPI.createPullRequest('eclipse-platform/eclipse.platform.releng.aggregator', prHeadline, """\
						Prepare development of Eclipse ${NEXT_RELEASE_VERSION}.
						This includes:
						- Updating the version of the Maven parent, all references to it and the Eclipse products to `${NEXT_RELEASE_VERSION}`
						- Updating the release version to `${NEXT_RELEASE_VERSION}` across build scripts
						- Updating the previous release version to the current Release-Candidate: `${PREVIOUS_RELEASE_CANDIDATE_ID}`
						""".stripIndent(), prBranch)
					
					utilities.forEachGitSubmodule{ submodulePath ->
						def diff = sh(script:"git diff master origin/master --shortstat", returnStdout: true).trim()
						if (diff.isEmpty()) {
							echo "Skipping submodule without changes: ${submodulePath}"
							return
						}
						def submoduleURL = sh(script: "git config remote.origin.url", returnStdout: true).trim()
						// Extract repository path from e.g.: https://github.com/eclipse-platform/eclipse.platform.git
						def expectedPrefix = 'https://github.com/'
						def expectedSuffix = '.git'
						if (!submoduleURL.startsWith(expectedPrefix) || !submoduleURL.endsWith(expectedSuffix)) {
							error "Unexpected of submodule URL: ${submoduleURL}"
						}
						def repoName = submoduleURL.substring(expectedPrefix.length(), submoduleURL.length() - expectedSuffix.length())
						githubAPI.createPullRequest(repoName, prHeadline, """\
							Prepare development of Eclipse ${NEXT_RELEASE_VERSION}.
							This complements:
							- ${aggregatorPreparationPR}
							""".stripIndent(), prBranch)
					}
					// Create maintenance branch preparation PR
					githubAPI.createPullRequest('eclipse-platform/eclipse.platform.releng.aggregator',
						"Move ${PREVIOUS_RELEASE_VERSION}-I builds to ${MAINTENANCE_BRANCH} branch", """\
						Prepare the maintenance branch for the ${PREVIOUS_RELEASE_VERSION} release.
						
						This completes the preparation of the subsequent ${NEXT_RELEASE_VERSION} release:
						- ${aggregatorPreparationPR}
						""".stripIndent(),"prepare-${MAINTENANCE_BRANCH}", "${MAINTENANCE_BRANCH}")
				}
			}
		}
		stage('Create Github milestones') {
			steps {
				script {
					def organisations = [ 'eclipse-platform', 'eclipse-jdt', 'eclipse-pde', 'eclipse-equinox' ]
					for (organisation in organisations) {
						def repositories = githubAPI.listReposOfOrganization(organisation)
						echo "${organisation} repositories: ${repositories.name}"
						for (repositoryData in repositories) {
							def repository = repositoryData.name
							if (repositoryData.archived) {
								echo "Skipping archived repository: ${repository}"
								continue
							} else if ('.eclipsefdn'.equals(repository)) {
								echo "Skipping .eclipsefdn repository of : ${organisation}"
								continue
							}
							releaseEvents.each{ name, description ->
								def title = "${NEXT_RELEASE_VERSION}" + (name != 'GA' ? " ${name}" : '')
								githubAPI.createMilestone(organisation, repository, title, "${NEXT_RELEASE_VERSION} ${description}", env["${name}_DATE"])
							}
						}
					}
				}
			}
		}
	}
}

@groovy.transform.Field
def utilities = null
@groovy.transform.Field
def githubAPI = null

// --- utility methods

@NonCPS
def assignEnvVariable(String name, Object value) {
	env[name] = value?.toString()
	println("${name}=${value}")
}

@NonCPS
def parseDate(String dateString) {
	return java.time.LocalDate.parse(dateString.trim()) // expects format 'yyyy-MM-dd'
}

private String createCronPattern(java.time.LocalDate start, java.time.LocalDate end, int hour, String daysOfWeek = '*') {
	def lastCompleteMonth = end.monthValue - 1
	// Consider end-of-year overflows
	def completeMonths = (start.monthValue < lastCompleteMonth) ? "${start.monthValue}-${lastCompleteMonth}" : "${start.monthValue}-12,1-${lastCompleteMonth}"
	return """\
		0 ${hour} * ${completeMonths} ${daysOfWeek}
		0 ${hour} 1-${end.dayOfMonth} ${end.monthValue} ${daysOfWeek}
	""".stripIndent()
}

def replaceInFile(String filePath, Map<String,String> replacements) {
	utilities.replaceAllInFile(filePath, replacements.collectEntries{ k, v -> [java.util.regex.Pattern.quote(k), v] });
}

def replaceAllInFile(String filePath, Map<String,String> replacements) {
	utilities.replaceAllInFile(filePath, replacements)
}

def gitCommitAllExcludingSubmodules(String commitMessage) {
	utilities.gitCommitAllExcludingSubmodules(commitMessage)
}
