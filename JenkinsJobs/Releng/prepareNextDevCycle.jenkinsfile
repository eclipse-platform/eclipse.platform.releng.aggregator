
pipeline {
	options {
		timestamps()
		timeout(time: 120, unit: 'MINUTES')
		buildDiscarder(logRotator(numToKeepStr:'5'))
		skipDefaultCheckout()
	}
	agent {
		label 'ubuntu-2404'
	}
	tools {
		jdk 'temurin-jdk21-latest'
		maven 'apache-maven-latest'
	}
	//Parameters are defined in the job definition
	stages {
		stage('Process Input') {
			steps {
				script {
					echo "DRY_RUN: ${DRY_RUN}"
					env.NEXT_RELEASE_VERSION = readParameter('NEXT_RELEASE_VERSION')
					def nextVersionMatcher = env.NEXT_RELEASE_VERSION =~ /(?<major>\d+)\.(?<minor>\d+)/
					if (!nextVersionMatcher.matches()) {
						error "Unexpected format for NEXT_RELEASE_VERSION: ${NEXT_RELEASE_VERSION}"
					}
					assignEnvVariable('NEXT_RELEASE_VERSION_MAJOR', nextVersionMatcher.group('major'))
					assignEnvVariable('NEXT_RELEASE_VERSION_MINOR', nextVersionMatcher.group('minor'))
					nextVersionMatcher = null // release matcher as it's not serializable
					
					env.PREVIOUS_RELEASE_CANDIDATE_ID = readParameter('PREVIOUS_RELEASE_CANDIDATE_ID')
					def previousIdMatcher = null
					if ((previousIdMatcher = env.PREVIOUS_RELEASE_CANDIDATE_ID =~ /(?<type>[SR])-(?<major>\d+)\.(?<minor>\d+)(\.(?<service>\d+))?(?<checkpoint>(M|RC)\d+[a-z]?)?-(?<date>\d{8})(?<time>\d{4})/).matches()) {
						def checkpoint = previousIdMatcher.group('checkpoint')
						assignEnvVariable('PREVIOUS_RELEASE_VERSION_MAJOR', previousIdMatcher.group('major'))
						assignEnvVariable('PREVIOUS_RELEASE_VERSION_MINOR', previousIdMatcher.group('minor'))
						assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_TAG', "${PREVIOUS_RELEASE_VERSION_MAJOR}.${PREVIOUS_RELEASE_VERSION_MINOR}${checkpoint}")
						def previousServiceVersion = previousIdMatcher.group('service') ?: '0'
						assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_GIT_TAG', "${previousIdMatcher.group('type')}${PREVIOUS_RELEASE_VERSION_MAJOR}_${PREVIOUS_RELEASE_VERSION_MINOR}${(checkpoint || previousServiceVersion != '0') ? ('_' + previousServiceVersion) : ''}${checkpoint ? ('_' + checkpoint) : ''}")
						
					} else if ((previousIdMatcher = env.PREVIOUS_RELEASE_CANDIDATE_ID =~ /I(?<date>\d{8})-(?<time>\d{4})/).matches()) {
						def buildPropertiesTxt = sh(script: "curl --fail https://download.eclipse.org/eclipse/downloads/drops4/${PREVIOUS_RELEASE_CANDIDATE_ID}/buildproperties.txt", returnStdout: true)
						def buildProperties = readProperties(text: buildPropertiesTxt)
						assignEnvVariable('PREVIOUS_RELEASE_VERSION_MAJOR', buildProperties.STREAMMajor.replace('"','')) // Remove surrounding quotes
						assignEnvVariable('PREVIOUS_RELEASE_VERSION_MINOR', buildProperties.STREAMMinor.replace('"','')) // Remove surrounding quotes
						assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_TAG', "${PREVIOUS_RELEASE_CANDIDATE_ID}")
						assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_GIT_TAG', "${PREVIOUS_RELEASE_CANDIDATE_ID}")
						
					} else {
						error "Unexpected format for PREVIOUS_RELEASE_CANDIDATE_ID: ${PREVIOUS_RELEASE_CANDIDATE_ID}"
					}
					assignEnvVariable('PREVIOUS_RELEASE_VERSION', "${PREVIOUS_RELEASE_VERSION_MAJOR}.${PREVIOUS_RELEASE_VERSION_MINOR}")
					assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_I_BUILD', "I${previousIdMatcher.group('date')}-${previousIdMatcher.group('time')}")
					previousIdMatcher = null // release matcher as it's not serializable
					
					//TODO: Read the dates from the calender instead of provide a structured document somewhere?
					// E.g. next to: https://github.com/eclipse-simrel/.github/blob/main/wiki/SimRel/2025-09.md
					def m1Date = parseDate(readParameter('M1_DATE'))
					def m2Date = parseDate(readParameter('M2_DATE'))
					def m3Date = parseDate(readParameter('M3_DATE'))
					def rc1Date = parseDate(readParameter('RC1_DATE'))
					def rc2Date = parseDate(readParameter('RC2_DATE'))
					def gaDate = parseDate(readParameter('GA_DATE'))
					if (!(m1Date < m2Date && m2Date < m3Date && m3Date < rc1Date && rc1Date < rc2Date && rc2Date < gaDate)) {
						error "Dates are not in strictly ascending order: ${M1_DATE}, ${M2_DATE}, ${M3_DATE}, ${RC1_DATE}, ${RC2_DATE}, ${GA_DATE}"
					}
					assignEnvVariable('NEXT_RELEASE_YEAR', gaDate.year.toString())
					assignEnvVariable('NEXT_RELEASE_MONTH', String.format("%02d", gaDate.monthValue))
					assignEnvVariable('NEXT_RELEASE_NAME', "${NEXT_RELEASE_YEAR}-${NEXT_RELEASE_MONTH}")
					assignEnvVariable('MAINTENANCE_BRANCH', "R${PREVIOUS_RELEASE_VERSION_MAJOR}_${PREVIOUS_RELEASE_VERSION_MINOR}_maintenance")
					
					// Compute new build schedule
					def now = java.time.LocalDate.now()
					def rcEnd = rc2Date.minusDays(2) // Wednesday before RC2 is the last planned I-build and the cron-triggers should stop after
					def lastCompleteMonth = rcEnd.monthValue - 1
					// Consider end-of-year overflows
					def completeMonths = (now.monthValue < lastCompleteMonth) ? "${now.monthValue}-${lastCompleteMonth}" : "${now.monthValue}-12,1-${lastCompleteMonth}"
					assignEnvVariable('I_BUILD_SCHEDULE', """\
						0 18 * ${completeMonths} *
						0 18 1-${rcEnd.dayOfMonth} ${rcEnd.monthValue} *
					""".stripIndent().trim())
				}
			}
		}
		stage('Checkout SCM') {
			steps {
				checkout scm
				script { // Always load the script from the very same state this pipeline is loaded (to ensure consistency)
					utilities = load "JenkinsJobs/shared/utilities.groovy"
					utilities.setDryRun(params.DRY_RUN)
					githubAPI = load "JenkinsJobs/shared/githubAPI.groovy"
					githubAPI.setDryRun(params.DRY_RUN)
				}
				sh '''#!/bin/bash -xe
					git submodule update --init --recursive --remote
					git config --global user.email 'releng-bot@eclipse.org'
					git config --global user.name 'Eclipse Releng Bot'
					
					# Create maintenance branch (at RC) and checkout master (to allow switching branches)
					function createBranches() {
						git checkout -B master HEAD
						git fetch origin tag "${PREVIOUS_RELEASE_CANDIDATE_GIT_TAG}"
						git branch ${MAINTENANCE_BRANCH} ${PREVIOUS_RELEASE_CANDIDATE_GIT_TAG}
						git reflog show master
						git reflog show ${MAINTENANCE_BRANCH}
					}
					createBranches
					export -f createBranches
					git submodule foreach 'createBranches'
				'''
			}
		}
		stage('Update Maven Version') {
			steps {
				sh '''
					mvn org.eclipse.tycho:tycho-versions-plugin:set-version \
						-DnewVersion=${NEXT_RELEASE_VERSION}.0-SNAPSHOT
					mvn -f eclipse-platform-parent/pom.xml tycho-versions:set-property \
						-Dproperties=releaseVersion,releaseYear,releaseMonth \
						-DnewReleaseVersion=${NEXT_RELEASE_VERSION} \
						-DnewReleaseYear=${NEXT_RELEASE_YEAR} \
						-DnewReleaseMonth=${NEXT_RELEASE_MONTH}
				'''
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/platform.product', [
					"eclipse/updates/${PREVIOUS_RELEASE_VERSION}" : "eclipse/updates/${NEXT_RELEASE_VERSION}",
					/releases\/20\d\d-\d\d" name="20\d\d-\d\d"/ : /releases\/${NEXT_RELEASE_NAME}" name="${NEXT_RELEASE_NAME}"/,
				])
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/sdk.product', [
					"eclipse/updates/${PREVIOUS_RELEASE_VERSION}" : "eclipse/updates/${NEXT_RELEASE_VERSION}",
					/releases\/20\d\d-\d\d" name="20\d\d-\d\d"/ : /releases\/${NEXT_RELEASE_NAME}" name="${NEXT_RELEASE_NAME}"/,
				])
				sh '''
					git commit --all --message "Prepare Release ${NEXT_RELEASE_VERSION}"
					git submodule foreach 'git commit --all --message "Update release version for ${NEXT_RELEASE_VERSION}" & echo done'
				'''
			}
		}
		stage('Update build scripts') {
			steps {
				replaceInFile('cje-production/buildproperties.txt', [
					"RELEASE_VER=\"${PREVIOUS_RELEASE_VERSION}\"" : "RELEASE_VER=\"${NEXT_RELEASE_VERSION}\"",
					"STREAM=\"${PREVIOUS_RELEASE_VERSION}.0\"" : "STREAM=\"${NEXT_RELEASE_VERSION}.0\"",
					"STREAMMajor=\"${PREVIOUS_RELEASE_VERSION_MAJOR}\"" : "STREAMMajor=\"${NEXT_RELEASE_VERSION_MAJOR}\"",
					"STREAMMinor=\"${PREVIOUS_RELEASE_VERSION_MINOR}\"" : "STREAMMinor=\"${NEXT_RELEASE_VERSION_MINOR}\"",
					"ECLIPSE_RUN_REPO=\"https://download.eclipse.org/eclipse/updates/${PREVIOUS_RELEASE_VERSION}-I-builds/\"" : "ECLIPSE_RUN_REPO=\"https://download.eclipse.org/eclipse/updates/${NEXT_RELEASE_VERSION}-I-builds/\"",
				])
				replaceInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/platform.p2.inf', [
					"${PREVIOUS_RELEASE_VERSION} Release" : "${NEXT_RELEASE_VERSION} Release",
				])
				replaceInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/sdk.p2.inf', [
					"${PREVIOUS_RELEASE_VERSION} Release" : "${NEXT_RELEASE_VERSION} Release",
				])
				replaceInFile('eclipse.platform.releng/features/org.eclipse.platform-feature/rootfiles/.eclipseproduct', [
					"version=${PREVIOUS_RELEASE_VERSION}.0" : "version=${NEXT_RELEASE_VERSION}.0",
				])
				replaceInFile('production/testScripts/configuration/streamSpecific.properties', [
					"for ${PREVIOUS_RELEASE_VERSION}.0 builds" : "for ${NEXT_RELEASE_VERSION}.0 builds",
				])
				replaceInFile('JenkinsJobs/JobDSL.json', [
					/"${PREVIOUS_RELEASE_VERSION}"/ : /"${NEXT_RELEASE_VERSION}"/,
				])
				replaceAllInFile('JenkinsJobs/Builds/FOLDER.groovy', [
					"(?<prefix># Schedule:.*\\R)(?s).*(?<suffix>\\R'''\\))" : "\${prefix}${I_BUILD_SCHEDULE}\${suffix}",
				])
				
				gitCommitAllExcludingSubmodules("Update versions to ${NEXT_RELEASE_VERSION} in build scripts")
			}
		}
		stage('Move previous version to current RC') {
			steps {
				sh '''
					mvn -f eclipse-platform-parent/pom.xml tycho-versions:set-property \
						-Dproperties=previous-release.baseline \
						"-DnewPrevious-release.baseline=https://download.eclipse.org/eclipse/updates/${PREVIOUS_RELEASE_VERSION}-I-builds/${PREVIOUS_RELEASE_CANDIDATE_I_BUILD}/"
				'''
				replaceAllInFile('cje-production/buildproperties.txt', [
					'PREVIOUS_RELEASE_VER=".*"' : "PREVIOUS_RELEASE_VER=\"${PREVIOUS_RELEASE_CANDIDATE_TAG}\"",
					'PREVIOUS_RELEASE_REPO_ID=".*"' : "PREVIOUS_RELEASE_REPO_ID=\"${PREVIOUS_RELEASE_VERSION}-I-builds\"",
					'BASEBUILD_ID=".*"' : "BASEBUILD_ID=\"${PREVIOUS_RELEASE_CANDIDATE_I_BUILD}\"",
					'PREVIOUS_RELEASE_ID=".*"' : "PREVIOUS_RELEASE_ID=\"${PREVIOUS_RELEASE_CANDIDATE_ID}\"",
				])
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse-junit-tests/src/main/resources/equinoxp2tests.properties', [
					'eclipse-platform-\\d+.\\d+-' : "eclipse-platform-${PREVIOUS_RELEASE_CANDIDATE_TAG}-",
					'org.eclipse.equinox.p2.tests.last.release.build.repo=.*' : "org.eclipse.equinox.p2.tests.last.release.build.repo=https://download.eclipse.org/equinox/drops/${PREVIOUS_RELEASE_CANDIDATE_ID}/",
				])
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse-junit-tests/src/main/resources/label.properties', [
					'previousReleaseVersion=.*' : "previousReleaseVersion=${PREVIOUS_RELEASE_CANDIDATE_TAG}",
				])
				replaceAllInFile('production/testScripts/configuration/streamSpecific.properties', [
					'previousReleaseLocation=.*' : 'previousReleaseLocation=https://\\${DOWNLOAD_HOST}/eclipse/downloads/drops4/' + PREVIOUS_RELEASE_CANDIDATE_ID + '/',
					'previousReleaseVersion=.*' : "previousReleaseVersion=${PREVIOUS_RELEASE_CANDIDATE_TAG}",
					'previousReleaseVersionRepo=.*' : "previousReleaseVersionRepo=${PREVIOUS_RELEASE_VERSION}-I-builds",
				])
				
				gitCommitAllExcludingSubmodules("Move previous version to ${PREVIOUS_RELEASE_CANDIDATE_TAG} in build scripts")
			}
		}
		stage('Clear Qualifier-update files') {
			steps {
				dir('eclipse.platform.common/bundles') {
					sh '''
						# Clear content of all forceQualifierUpdate files in this directory
						for file in */forceQualifierUpdate.txt; do
							> "$file"
						done
						# Commit cleared files, if there was content to remove
						if [ -n "$(git diff --shortstat .)" ] ; then
							git commit --message "Clean forceQualifierUpdate files of doc bundles for ${NEXT_RELEASE_VERSION} development" .
						else
							echo 'The forceQualifierUpdate files of all doc bundles are already empty. Nothing to do.'
						fi
					'''
				}
			}
		}
		stage('Apply individual updates') {
			environment {
				UPDATE_SCRIPT = 'prepareNextDevCycle.sh'
			}
			steps {
				sh '''
					git submodule foreach 'if [ -f ${UPDATE_SCRIPT} ]; then chmod +x ./${UPDATE_SCRIPT} && ./${UPDATE_SCRIPT}; fi'
				'''
			}
		}
		stage('Prepare maintenance branch') {
			steps {
				// Apply the following changes at a preparation branch, starting at the maintenance branch (to create a PR later)
				sh 'git checkout -b prepareMaintenance ${MAINTENANCE_BRANCH}'
				
				replaceInFile('JenkinsJobs/JobDSL.json', [
					"\"${PREVIOUS_RELEASE_VERSION}\": \"master\"" : "\"${PREVIOUS_RELEASE_VERSION}\": \"${MAINTENANCE_BRANCH}\"",
				])
				replaceInFile('JenkinsJobs/Builds/build.jenkinsfile', [
					"typeName: 'Integration' , branchLabel: 'master'" : "typeName: 'Integration' , branchLabel: '${MAINTENANCE_BRANCH}'",
				])
				replaceInFile('JenkinsJobs/Builds/DockerImagesBuild.jenkinsfile', [
					'-b master' : "-b ${MAINTENANCE_BRANCH}",
				])
				replaceAllInFile('JenkinsJobs/Builds/FOLDER.groovy', [
					"spec\\('''(?s).+?'''\\)" : "spec('')",
					"'master'" : "'${MAINTENANCE_BRANCH}'",
				])
				replaceInFile('cje-production/buildproperties.txt', [
					'BRANCH="master"' : "BRANCH=\"${MAINTENANCE_BRANCH}\"",
				])
				replaceInFile('cje-production/streams/repositories_java25.txt', [
					': master' : ": ${MAINTENANCE_BRANCH}",
				])
				replaceInFile('cje-production/streams/repositories_master.txt', [
					': master' : ": ${MAINTENANCE_BRANCH}",
				])
				sh "mv cje-production/streams/repositories_master.txt cje-production/streams/repositories_${MAINTENANCE_BRANCH}.txt"
				
				gitCommitAllExcludingSubmodules("Move ${PREVIOUS_RELEASE_VERSION}-I builds to ${MAINTENANCE_BRANCH} branch")
				
				// Switch back to master for subsequent parts of this pipeline
				sh 'git checkout master'
			}
		}
		stage('Validate and list changes') {
			steps {
				sh '''
					function printLatestGitHistory() {
						git log origin/master..master --patch-with-stat --summary
					}
					printLatestGitHistory
					export -f printLatestGitHistory
					git submodule foreach 'printLatestGitHistory'
					
					echo 'Print history of maintenance branch'
					git log refs/tags/${PREVIOUS_RELEASE_CANDIDATE_GIT_TAG}..prepareMaintenance --patch-with-stat --summary
				'''
				// Run simple clean build to verify that at least all parent versions are updated correctly
				sh 'mvn clean'
				// search for leftover occurrences of the previous release version
				sh '''#!/bin/bash -e
					matchingFiles=$(grep --recursive --files-with-matches \
						--include pom.xml \
						--include MANIFEST.MF \
						--include feature.xml \
						--include \\*.product \
						--fixed-strings "${PREVIOUS_RELEASE_VERSION}")
					# The eclipse-platform-parent/pom.xml contains the previous version in the baseline repository variable
					if [[ -z "${matchingFiles}" ]] || [[ "${matchingFiles}" == 'eclipse-platform-parent/pom.xml' ]]; then
						echo "No unexpected references to previous version ${PREVIOUS_RELEASE_VERSION} found."
						exit 0
					else
						echo "References to previous version ${PREVIOUS_RELEASE_VERSION} found:"
						for f in ${matchingFiles}; do
							echo "In file ${f}"
							grep "${PREVIOUS_RELEASE_VERSION}" "${f}"
						done
						exit 1
					fi
				'''
			}
		}
		stage ('Create and update Stream Repos') {
			when {
				not { expression { params.DRY_RUN } }
			}
			steps {
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/${NEXT_RELEASE_VERSION}-I-builds"),
					string(name: 'repositoryName', value: "Eclipse ${NEXT_RELEASE_VERSION} integration builds"),
					string(name: 'add', value: "https://download.eclipse.org/eclipse/updates/${PREVIOUS_RELEASE_VERSION}-I-builds/${PREVIOUS_RELEASE_CANDIDATE_I_BUILD}/")
					// Size-limit is not relevant, the repository is initially empty.
				]
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/${NEXT_RELEASE_VERSION}-Y-builds"),
					string(name: 'repositoryName', value: "Eclipse ${NEXT_RELEASE_VERSION} Beta Java builds")
				]
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/${NEXT_RELEASE_VERSION}"),
					string(name: 'repositoryName', value: "Eclipse ${NEXT_RELEASE_VERSION} release")
				]
				// Update generic composite repositories for I/Y-builds (clearing all previous children)
				// Note: The stream number is not in the 'name', because once a 'name' is defined in Eclipse's UI, it does not change.
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/I-builds"),
					string(name: 'repositoryName', value: "Eclipse latest integration builds"),
					string(name: 'sizeLimit', value: '1'), // Clear all previous children
					string(name: 'add', value: "https://download.eclipse.org/eclipse/updates/${NEXT_RELEASE_VERSION}-I-builds/"),
				]
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/Y-builds"),
					string(name: 'repositoryName', value: "Eclipse latest Beta Java builds"),
					string(name: 'sizeLimit', value: '1'), // Clear all previous children
					string(name: 'add', value: "https://download.eclipse.org/eclipse/updates/${NEXT_RELEASE_VERSION}-Y-builds/"),
				]
			}
		}
		stage('Deploy parent-pom and SDK-target') {
			// Deploy new parent first to ensure it's available when PRs for submodule updates are created.
			environment {
				GOAL ="${ params.DRY_RUN ? 'install' : 'deploy' }"
			}
			steps {
				sh '''
					mvn clean ${GOAL} -f eclipse-platform-parent/pom.xml
					mvn clean ${GOAL} -f eclipse.platform.releng.prereqs.sdk/pom.xml
				'''
			}
		}
		stage('Push preparation branches') {
			steps {
				script {
					utilities.runHereAndForEachGitSubmodule{
						utilities.gitPushBranch('master', "prepare-R${NEXT_RELEASE_VERSION}")
						utilities.gitPushBranch("${MAINTENANCE_BRANCH}", "${MAINTENANCE_BRANCH}")
					}
					// Push preparation of the maintenance to a separate branch (not directly to the maintenance branch),
					// to enable creating a PR against the maintenance branch from it.
					utilities.gitPushBranch('prepareMaintenance', "prepare-${MAINTENANCE_BRANCH}")
				}
			}
		}
		stage('Create preparation Pull-Requests') {
			steps {
				script {
					def prHeadline = "Prepare ${NEXT_RELEASE_VERSION} development"
					def prBranch = "prepare-R${NEXT_RELEASE_VERSION}"
					def aggregatorPreparationPR = githubAPI.createPullRequest('eclipse-platform/eclipse.platform.releng.aggregator', prHeadline, """\
						Prepare development of Eclipse ${NEXT_RELEASE_VERSION}.
						This includes:
						- Updating the version of the Maven parent, all references to it and the Eclipse products to `${NEXT_RELEASE_VERSION}`
						- Updating the release version to `${NEXT_RELEASE_VERSION}` across build scripts
						- Updating the previous release version to the current Release-Candidate: `${PREVIOUS_RELEASE_CANDIDATE_ID}`
						""".stripIndent(), prBranch)
					
					utilities.forEachGitSubmodule{ submodulePath ->
						def diff = sh(script:"git diff master origin/master --shortstat", returnStdout: true).trim()
						if (diff.isEmpty()) {
							echo "Skipping submodule without changes: ${submodulePath}"
							return
						}
						def submoduleURL = sh(script: "git config remote.origin.url", returnStdout: true).trim()
						// Extract repository path from e.g.: https://github.com/eclipse-platform/eclipse.platform.git
						def expectedPrefix = 'https://github.com/'
						def expectedSuffix = '.git'
						if (!submoduleURL.startsWith(expectedPrefix) || !submoduleURL.endsWith(expectedSuffix)) {
							error "Unexpected of submodule URL: ${submoduleURL}"
						}
						def repoName = submoduleURL.substring(expectedPrefix.length(), submoduleURL.length() - expectedSuffix.length())
						githubAPI.createPullRequest(repoName, prHeadline, """\
							Prepare development of Eclipse ${NEXT_RELEASE_VERSION}.
							This complements:
							- ${aggregatorPreparationPR}
							""".stripIndent(), prBranch)
					}
					// Create maintenance branch preparation PR
					githubAPI.createPullRequest('eclipse-platform/eclipse.platform.releng.aggregator',
						"Move ${PREVIOUS_RELEASE_VERSION}-I builds to ${MAINTENANCE_BRANCH} branch", """\
						Prepare the maintenance branch for the ${PREVIOUS_RELEASE_VERSION} release.
						
						This completes the preparation of the subsequent ${NEXT_RELEASE_VERSION} release:
						- ${aggregatorPreparationPR}
						""".stripIndent(),"prepare-${MAINTENANCE_BRANCH}", "${MAINTENANCE_BRANCH}")
				}
			}
		}
		stage('Create Github milestones') {
			steps {
				script {
					def organisations = [ 'eclipse-platform', 'eclipse-jdt', 'eclipse-pde', 'eclipse-equinox' ]
					for (organisation in organisations) {
						def repositories = githubAPI.listReposOfOrganization(organisation)
						echo "${organisation} repositories: ${repositories.name}"
						for (repositoryData in repositories) {
							def repository = repositoryData.name
							if (repositoryData.archived) {
								echo "Skipping archived repository: ${repository}"
								continue
							} else if ('.eclipsefdn'.equals(repository)) {
								echo "Skipping .eclipsefdn repository of : ${organisation}"
								continue
							}
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION} M1",  "${NEXT_RELEASE_VERSION} Milestone 1",         "${M1_DATE}")
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION} M2",  "${NEXT_RELEASE_VERSION} Milestone 2",         "${M2_DATE}")
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION} M3",  "${NEXT_RELEASE_VERSION} Milestone 3",         "${M3_DATE}")
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION} RC1", "${NEXT_RELEASE_VERSION} Release Candidate 1", "${RC1_DATE}")
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION} RC2", "${NEXT_RELEASE_VERSION} Release Candidate 2", "${RC2_DATE}")
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION}",     "${NEXT_RELEASE_VERSION} Release",             "${GA_DATE}")
						}
					}
				}
			}
		}
	}
}

@groovy.transform.Field
def utilities = null
@groovy.transform.Field
def githubAPI = null

// --- utility methods

@NonCPS
def readParameter(String name) {
	//TODO: let jenkins trim the parameters
	def value = (params[name] ?: '').trim()
	println("${name}: ${value}")
	return value
}

@NonCPS
def assignEnvVariable(String name, String value) {
	env."${name}" = value
	println("${name}=${value}")
}

@NonCPS
def parseDate(String dateString) {
	return java.time.LocalDate.parse(dateString.trim()) // expects format 'yyyy-MM-dd'
}

def replaceInFile(String filePath, Map<String,String> replacements) {
	utilities.replaceInFile(filePath, replacements)
}

def replaceAllInFile(String filePath, Map<String,String> replacements) {
	utilities.replaceAllInFile(filePath, replacements)
}

def gitCommitAllExcludingSubmodules(String commitMessage) {
	utilities.gitCommitAllExcludingSubmodules(commitMessage)
}
