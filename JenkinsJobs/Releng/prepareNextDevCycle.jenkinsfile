
pipeline {
	options {
		timestamps()
		timeout(time: 120, unit: 'MINUTES')
		buildDiscarder(logRotator(numToKeepStr:'5'))
		skipDefaultCheckout()
	}
	agent {
		label 'ubuntu-2404'
	}
	tools {
		jdk 'temurin-jdk21-latest'
		maven 'apache-maven-latest'
	}
	//Parameters are defined in the job definition
	stages {
		stage('Process Input') {
			steps {
				script {
					echo "DRY_RUN: ${DRY_RUN}"
					env.NEXT_RELEASE_VERSION = readParameter('NEXT_RELEASE_VERSION')
					def nextVersionMatcher = env.NEXT_RELEASE_VERSION =~ /(?<major>\d+)\.(?<minor>\d+)/
					if (!nextVersionMatcher.matches()) {
						error "Unexpected format for NEXT_RELEASE_VERSION: ${NEXT_RELEASE_VERSION}"
					}
					assignEnvVariable('NEXT_RELEASE_VERSION_MAJOR', nextVersionMatcher.group('major'))
					assignEnvVariable('NEXT_RELEASE_VERSION_MINOR', nextVersionMatcher.group('minor'))
					nextVersionMatcher = null // release matcher as it's not serializable
					
					env.PREVIOUS_RELEASE_CANDIDATE_ID = readParameter('PREVIOUS_RELEASE_CANDIDATE_ID')
					def previousIdMatcher = env.PREVIOUS_RELEASE_CANDIDATE_ID =~ /(S|R)-(?<major>\d+)\.(?<minor>\d+)(\.\d+)?(?<checkpoint>(M|RC)\d+[a-z]?)?-(?<date>\d{8})(?<time>\d{4})/
					if (!previousIdMatcher.matches()) {
						error "Unexpected format for PREVIOUS_RELEASE_CANDIDATE_ID: ${PREVIOUS_RELEASE_CANDIDATE_ID}"
					}
					assignEnvVariable('PREVIOUS_RELEASE_VERSION_MAJOR', previousIdMatcher.group('major'))
					assignEnvVariable('PREVIOUS_RELEASE_VERSION_MINOR', previousIdMatcher.group('minor'))
					assignEnvVariable('PREVIOUS_RELEASE_VERSION', "${PREVIOUS_RELEASE_VERSION_MAJOR}.${PREVIOUS_RELEASE_VERSION_MINOR}")
					assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_TAG', "${PREVIOUS_RELEASE_VERSION}${previousIdMatcher.group('checkpoint')}")
					assignEnvVariable('PREVIOUS_RELEASE_CANDIDATE_I_BUILD', "I${previousIdMatcher.group('date')}-${previousIdMatcher.group('time')}")
					previousIdMatcher = null // release matcher as it's not serializable
					
					//TODO: Read the dates from the calender instead of provide a structured document somewhere?
					// E.g. next to: https://github.com/eclipse-simrel/.github/blob/main/wiki/SimRel/2025-09.md
					def m1Date = parseDate(readParameter('M1_DATE'))
					def m2Date = parseDate(readParameter('M2_DATE'))
					def m3Date = parseDate(readParameter('M3_DATE'))
					def rc1Date = parseDate(readParameter('RC1_DATE'))
					def rc2Date = parseDate(readParameter('RC2_DATE'))
					def gaDate = parseDate(readParameter('GA_DATE'))
					if (!(m1Date < m2Date && m2Date < m3Date && m3Date < rc1Date && rc1Date < rc2Date && rc2Date < gaDate)) {
						error "Dates are not in strictly ascending order: ${M1_DATE}, ${M2_DATE}, ${M3_DATE}, ${RC1_DATE}, ${RC2_DATE}, ${GA_DATE}"
					}
					assignEnvVariable('NEXT_RELEASE_YEAR', gaDate.year.toString())
					assignEnvVariable('NEXT_RELEASE_MONTH', String.format("%02d", gaDate.monthValue))
					assignEnvVariable('NEXT_RELEASE_NAME', "${NEXT_RELEASE_YEAR}-${NEXT_RELEASE_MONTH}")
				}
			}
		}
		stage('Checkout SCM') {
			steps {
				checkout scm
				script { // Always load the script from the very same state this pipeline is loaded (to ensure consistency)
					githubAPI = load "JenkinsJobs/shared/githubAPI.groovy"
					githubAPI.setDryRun(params.DRY_RUN)
				}
				sh '''
					git submodule update --init --recursive
					git config --global user.email 'releng-bot@eclipse.org'
					git config --global user.name 'Eclipse Releng Bot'
				'''
			}
		}
		stage('Update Maven Version') {
			environment {
				MAVEN_ARGS = '-U -B -ntp'
			}
			steps {
				sh '''
					mvn org.eclipse.tycho:tycho-versions-plugin:set-version \
						-DnewVersion=${NEXT_RELEASE_VERSION}.0-SNAPSHOT
					mvn -f eclipse-platform-parent/pom.xml --non-recursive org.eclipse.tycho:tycho-versions-plugin:set-property \
						-Dproperties=releaseVersion,releaseYear,releaseMonth \
						-DnewReleaseVersion=${NEXT_RELEASE_VERSION} \
						-DnewReleaseYear=${NEXT_RELEASE_YEAR} \
						-DnewReleaseMonth=${NEXT_RELEASE_MONTH}
				'''
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/platform.product', [
					"eclipse/updates/${PREVIOUS_RELEASE_VERSION}" : "eclipse/updates/${NEXT_RELEASE_VERSION}",
					/releases\/20\d\d-\d\d" name="20\d\d-\d\d"/ : /releases\/${NEXT_RELEASE_NAME}" name="${NEXT_RELEASE_NAME}"/,
				])
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/sdk.product', [
					"eclipse/updates/${PREVIOUS_RELEASE_VERSION}" : "eclipse/updates/${NEXT_RELEASE_VERSION}",
					/releases\/20\d\d-\d\d" name="20\d\d-\d\d"/ : /releases\/${NEXT_RELEASE_NAME}" name="${NEXT_RELEASE_NAME}"/,
				])
				sh '''
					git commit --all --message "Prepare Release ${NEXT_RELEASE_VERSION}"
					git submodule foreach 'git commit --all --message "Update release version for ${NEXT_RELEASE_VERSION}" & echo done'
				'''
			}
		}
		stage('Update build scripts') {
			steps {
				replaceInFile('cje-production/buildproperties.txt', [
					"RELEASE_VER=\"${PREVIOUS_RELEASE_VERSION}\"" : "RELEASE_VER=\"${NEXT_RELEASE_VERSION}\"",
					"STREAM=\"${PREVIOUS_RELEASE_VERSION}.0\"" : "STREAM=\"${NEXT_RELEASE_VERSION}.0\"",
					"STREAMMajor=\"${PREVIOUS_RELEASE_VERSION_MAJOR}\"" : "STREAMMajor=\"${NEXT_RELEASE_VERSION_MAJOR}\"",
					"STREAMMinor=\"${PREVIOUS_RELEASE_VERSION_MINOR}\"" : "STREAMMinor=\"${NEXT_RELEASE_VERSION_MINOR}\"",
					"ECLIPSE_RUN_REPO=\"https://download.eclipse.org/eclipse/updates/${PREVIOUS_RELEASE_VERSION}-I-builds/\"" : "ECLIPSE_RUN_REPO=\"https://download.eclipse.org/eclipse/updates/${NEXT_RELEASE_VERSION}-I-builds/\"",
				])
				replaceInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/platform.p2.inf', [
					"${PREVIOUS_RELEASE_VERSION} Release" : "${NEXT_RELEASE_VERSION} Release",
				])
				replaceInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse.platform.repository/sdk.p2.inf', [
					"${PREVIOUS_RELEASE_VERSION} Release" : "${NEXT_RELEASE_VERSION} Release",
				])
				replaceInFile('eclipse.platform.releng/features/org.eclipse.platform-feature/rootfiles/.eclipseproduct', [
					"version=${PREVIOUS_RELEASE_VERSION}.0" : "version=${NEXT_RELEASE_VERSION}.0",
				])
				replaceInFile('production/testScripts/configuration/streamSpecific.properties', [
					"for ${PREVIOUS_RELEASE_VERSION}.0 builds" : "for ${NEXT_RELEASE_VERSION}.0 builds",
				])
				
				commitAllChangesExcludingSubmodules("Update versions to ${NEXT_RELEASE_VERSION} in build scripts")
			}
		}
		stage('Move previous version to current RC') {
			steps {
				sh '''
					mvn -f eclipse-platform-parent/pom.xml --non-recursive org.eclipse.tycho:tycho-versions-plugin:set-property \
						-Dproperties=previous-release.baseline \
						"-DnewPrevious-release.baseline=https://download.eclipse.org/eclipse/updates/${PREVIOUS_RELEASE_VERSION}-I-builds/${PREVIOUS_RELEASE_CANDIDATE_I_BUILD}/"
				'''
				replaceAllInFile('cje-production/buildproperties.txt', [
					'PREVIOUS_RELEASE_VER=".*"' : "PREVIOUS_RELEASE_VER=\"${PREVIOUS_RELEASE_CANDIDATE_TAG}\"",
					'PREVIOUS_RELEASE_REPO_ID=".*"' : "PREVIOUS_RELEASE_REPO_ID=\"${PREVIOUS_RELEASE_VERSION}-I-builds\"",
					'BASEBUILD_ID=".*"' : "BASEBUILD_ID=\"${PREVIOUS_RELEASE_CANDIDATE_I_BUILD}\"",
					'PREVIOUS_RELEASE_ID=".*"' : "PREVIOUS_RELEASE_ID=\"${PREVIOUS_RELEASE_CANDIDATE_ID}\"",
				])
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse-junit-tests/src/main/resources/equinoxp2tests.properties', [
					'eclipse-platform-\\d+.\\d+-' : "eclipse-platform-${PREVIOUS_RELEASE_CANDIDATE_TAG}-",
					'org.eclipse.equinox.p2.tests.last.release.build.repo=.*' : "org.eclipse.equinox.p2.tests.last.release.build.repo=https://download.eclipse.org/equinox/drops/${PREVIOUS_RELEASE_CANDIDATE_ID}/",
				])
				replaceAllInFile('eclipse.platform.releng.tychoeclipsebuilder/eclipse-junit-tests/src/main/resources/label.properties', [
					'previousReleaseVersion=.*' : "previousReleaseVersion=${PREVIOUS_RELEASE_CANDIDATE_TAG}",
				])
				replaceAllInFile('production/testScripts/configuration/streamSpecific.properties', [
					'previousReleaseLocation=.*' : 'previousReleaseLocation=https://\\${DOWNLOAD_HOST}/eclipse/downloads/drops4/' + PREVIOUS_RELEASE_CANDIDATE_ID + '/',
					'previousReleaseVersion=.*' : "previousReleaseVersion=${PREVIOUS_RELEASE_CANDIDATE_TAG}",
					'previousReleaseVersionRepo=.*' : "previousReleaseVersionRepo=${PREVIOUS_RELEASE_VERSION}-I-builds",
				])
				commitAllChangesExcludingSubmodules("Move previous version to ${PREVIOUS_RELEASE_CANDIDATE_TAG} in build scripts")
			}
		}
		stage('Apply individual updates') {
			environment {
				UPDATE_SCRIPT = 'prepareNextDevCycle.sh'
			}
			steps {
				sh '''
					git submodule foreach 'if [ -f ${UPDATE_SCRIPT} ]; then chmod +x ./${UPDATE_SCRIPT} && ./${UPDATE_SCRIPT}; fi'
				'''
			}
		}
		stage('Validate and list changes') {
			steps {
				sh '''
					function printLatestGitHistory() {
						git log origin/master..HEAD --patch-with-stat --summary
					}
					printLatestGitHistory
					export -f printLatestGitHistory
					git submodule foreach 'printLatestGitHistory'
				'''
				// Run simple clean build to verify that at least all parent versions are updated correctly
				sh 'mvn clean'
				// search for leftover occurrences of the previous release version
				sh '''#!/bin/bash -e
					matchingFiles=$(grep --recursive --files-with-matches \
						--include pom.xml \
						--include MANIFEST.MF \
						--include feature.xml \
						--include \\*.product \
						--fixed-strings "${PREVIOUS_RELEASE_VERSION}")
					# The eclipse-platform-parent/pom.xml contains the previous version in the baseline repository variable
					if [[ -z "${matchingFiles}" ]] || [[ "${matchingFiles}" == 'eclipse-platform-parent/pom.xml' ]]; then
						echo "No unexpected references to previous version ${PREVIOUS_RELEASE_VERSION} found:"
						exit 0
					else
						echo "References to previous version ${PREVIOUS_RELEASE_VERSION} found:"
						for f in ${matchingFiles}; do
							echo "In file ${f}"
							grep "${PREVIOUS_RELEASE_VERSION}" "${f}"
						done
						exit 1
					fi
				'''
			}
		}
		stage ('Create and update Stream Repos') {
			when {
				not { expression { params.DRY_RUN } }
			}
			steps {
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/${NEXT_RELEASE_VERSION}-I-builds"),
					string(name: 'repositoryName', value: "Eclipse ${NEXT_RELEASE_VERSION} integration builds"),
					string(name: 'add', value: "https://download.eclipse.org/eclipse/updates/${PREVIOUS_RELEASE_VERSION}-I-builds/${PREVIOUS_RELEASE_CANDIDATE_I_BUILD}/")
					// Size-limit is not relevant, the repository is initially empty.
				]
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/${NEXT_RELEASE_VERSION}-Y-builds"),
					string(name: 'repositoryName', value: "Eclipse ${NEXT_RELEASE_VERSION} Beta Java builds")
				]
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/${NEXT_RELEASE_VERSION}"),
					string(name: 'repositoryName', value: "Eclipse ${NEXT_RELEASE_VERSION} release")
				]
				// Update generic composite repositories for I/Y-builds (clearing all previous children)
				// Note: The stream number is not in the 'name', because once a 'name' is defined in Eclipse's UI, it does not change.
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/I-builds"),
					string(name: 'repositoryName', value: "Eclipse latest integration builds"),
					string(name: 'sizeLimit', value: '1'), // Clear all previous children
					string(name: 'add', value: "https://download.eclipse.org/eclipse/updates/${NEXT_RELEASE_VERSION}-I-builds/"),
				]
				build job: 'Releng/modifyP2CompositeRepository', wait: true, propagate: true, parameters: [
					string(name: 'repositoryPath', value: "eclipse/updates/Y-builds"),
					string(name: 'repositoryName', value: "Eclipse latest Beta Java builds"),
					string(name: 'sizeLimit', value: '1'), // Clear all previous children
					string(name: 'add', value: "https://download.eclipse.org/eclipse/updates/${NEXT_RELEASE_VERSION}-Y-builds/"),
				]
			}
		}
		stage('Deploy parent-pom and SDK-target') {
			// Deploy new parent first to ensure it's available when PRs for submodule updates are created.
			environment {
				GOAL ="${ params.DRY_RUN ? 'install' : 'deploy' }"
			}
			steps {
				sh '''
					mvn clean ${GOAL} -f eclipse-platform-parent/pom.xml
					mvn clean ${GOAL} -f eclipse.platform.releng.prereqs.sdk/pom.xml
				'''
			}
		}
		stage('Push preparation branches') {
			steps {
				sshagent (['github-bot-ssh']) {
					sh '''#!/bin/bash -x
						function pushNewCommitsToPreparationBranch() {
							pushURL=$(git config remote.origin.url)
							# Switch to SSH, if the configured URL uses HTTPS (we can only push with SSH)
							if [[ "$pushURL" == http* ]]; then
								pushURL=$(echo $pushURL|sed --expression 's|https://github.com/|git@github.com:|')
							fi
							if [[ ${DRY_RUN} == 'true' ]]; then
								dryRunFlag='--dry-run'
							fi
							git push ${dryRunFlag} ${pushURL} HEAD:refs/heads/prepare_R${NEXT_RELEASE_VERSION}
						}
						pushNewCommitsToPreparationBranch
						export -f pushNewCommitsToPreparationBranch
						git submodule foreach 'pushNewCommitsToPreparationBranch'
					'''
				}
			}
		}
		stage('Create preparation Pull-Requests') {
			environment {
				GITHUB_BOT_TOKEN = credentials('github-bot-token')
			}
			steps {
				script {
					def prHeadline = "Prepare ${NEXT_RELEASE_VERSION} development"
					def prBranch = "prepare_R${NEXT_RELEASE_VERSION}"
					def aggregatorPreparationPR = githubAPI.createPullRequest('eclipse-platform/eclipse.platform.releng.aggregator', prHeadline, """\
						Prepare development of Eclipse ${NEXT_RELEASE_VERSION}.
						This includes:
						- Updating the version of the Maven parent, all references to it and the Eclipse products to `${NEXT_RELEASE_VERSION}`
						- Updating the release version to `${NEXT_RELEASE_VERSION}` across build scripts
						- Updating the previous release version to the current Release-Candidate: `${PREVIOUS_RELEASE_CANDIDATE_ID}`
						""".stripIndent(), prBranch)
						
					def submodulePaths = sh(script: "git submodule --quiet foreach 'echo \$sm_path'", returnStdout: true).trim().split('\\s')
					for (submodulePath in submodulePaths) {
						def diff = sh(script:"cd ${submodulePath} && git diff HEAD origin/master --shortstat", returnStdout: true).trim()
						if (diff.isEmpty()) {
							echo "Skipping submodule without changes: ${submodulePath}"
							continue
						}
						def submoduleURL = sh(script: "cd ${submodulePath} && git config remote.origin.url", returnStdout: true).trim()
						// Extract repository path from e.g.: https://github.com/eclipse-platform/eclipse.platform.git
						def expectedPrefix = 'https://github.com/'
						def expectedSuffix = '.git'
						if (!submoduleURL.startsWith(expectedPrefix) || !submoduleURL.endsWith(expectedSuffix)) {
							error "Unexpected of submodule URL: ${submoduleURL}"
						}
						def repoName = submoduleURL.substring(expectedPrefix.length(), submoduleURL.length() - expectedSuffix.length())
						githubAPI.createPullRequest(repoName, prHeadline, """\
							Prepare development of Eclipse ${NEXT_RELEASE_VERSION}.
							This complements:
							- ${aggregatorPreparationPR}
							""".stripIndent(), prBranch)
					}
				}
			}
		}
		stage('Create Github milestones') {
			environment {
				GITHUB_BOT_TOKEN = credentials('github-bot-token')
			}
			steps {
				script {
					def organisations = [ 'eclipse-platform', 'eclipse-jdt', 'eclipse-pde', 'eclipse-equinox' ]
					for (organisation in organisations) {
						def repositories = githubAPI.listReposOfOrganization(organisation)
						echo "${organisation} repositories: ${repositories.name}"
						for (repositoryData in repositories) {
							def repository = repositoryData.name
							if (repositoryData.archived) {
								echo "Skipping archived repository: ${repository}"
								continue
							} else if ('.eclipsefdn'.equals(repository)) {
								echo "Skipping .eclipsefdn repository of : ${organisation}"
								continue
							}
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION} M1",  "${NEXT_RELEASE_VERSION} Milestone 1",         "${M1_DATE}")
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION} M2",  "${NEXT_RELEASE_VERSION} Milestone 2",         "${M2_DATE}")
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION} M3",  "${NEXT_RELEASE_VERSION} Milestone 3",         "${M3_DATE}")
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION} RC1", "${NEXT_RELEASE_VERSION} Release Candidate 1", "${RC1_DATE}")
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION} RC2", "${NEXT_RELEASE_VERSION} Release Candidate 2", "${RC2_DATE}")
							githubAPI.createMilestone(organisation, repository, "${NEXT_RELEASE_VERSION}",     "${NEXT_RELEASE_VERSION} Release",             "${GA_DATE}")
						}
					}
				}
			}
		}
	}
}

@groovy.transform.Field
def githubAPI = null

// --- utility methods

@NonCPS
def readParameter(String name) {
	//TODO: let jenkins trim the parameters
	def value = (params[name] ?: '').trim()
	println("${name}: ${value}")
	return value
}

@NonCPS
def assignEnvVariable(String name, String value) {
	env."${name}" = value
	println("${name}=${value}")
}

@NonCPS
def parseDate(String dateString) {
	return java.time.LocalDate.parse(dateString.trim()) // expects format 'yyyy-MM-dd'
}

def replaceInFile(String filePath, Map<String,String> replacements) {
	replaceAllInFile(filePath, replacements.collectEntries{ k, v -> [java.util.regex.Pattern.quote(k), v] });
}

def replaceAllInFile(String filePath, Map<String,String> replacements) {
	def content = readFile(filePath)
	for (entry in replacements) {
		def newContent = content.replaceAll(entry.key, entry.value)
		if (newContent == content && !(content =~ entry.key)) { // pattern matches, but the replacement is equal to the current content
			error("Pattern not found in file '${filePath}': ${entry.key}")
		}
		content = newContent
	}
	writeFile(file:filePath, text: content)
}

def commitAllChangesExcludingSubmodules(String commitMessage) {
	withEnv(["COMMIT_MESSAGE=${commitMessage}"]) {
		sh '''
			#Commit all changes, except for the updated sub-modules here
			git add --all
			git restore --staged $(git submodule foreach --quiet 'echo $sm_path')
			git commit --message "${COMMIT_MESSAGE}"
		'''
	}
}
